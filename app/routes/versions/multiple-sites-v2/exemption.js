// Generated by Copilot
const { log } = require("govuk-prototype-kit/migrator/logger");

// LEGACY IMPORT REMOVED: exemption-manual-entry.js
// The manual entry renumbering function has been replaced by unified model functions

// Function to get activity information based on article number
function getActivityInfoForArticle(article) {
    const activityMappings = {
        '13': {
            typeOfActivity: 'Construction of works',
            purpose: 'Infrastructure development',
            involves: 'Building marine structures',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/13'
        },
        '17': {
            typeOfActivity: 'Removal of a substance or object',
            purpose: 'Scientific research',
            involves: 'Samples for testing and analysis',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/17'
        },
        '17A': {
            typeOfActivity: 'Removal of a substance or object',
            purpose: 'Scientific research',
            involves: 'Samples for testing and analysis',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/17A'
        },
        '17B': {
            typeOfActivity: 'Deposit of a substance or object',
            purpose: 'Scientific research',
            involves: 'Marine monitoring equipment',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/17B'
        },
        '18A': {
            typeOfActivity: 'Construction of works',
            purpose: 'Scientific research',
            involves: 'Temporary research installations',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/18A'
        },
        '20': {
            typeOfActivity: 'Construction of works',
            purpose: 'Emergency works',
            involves: 'Emergency repairs and safety measures',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/20'
        },
        '21': {
            typeOfActivity: 'Dredging',
            purpose: 'Navigation maintenance',
            involves: 'Channel maintenance and deepening',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/21'
        },
        '25': {
            typeOfActivity: 'Deposit of a substance or object',
            purpose: 'Habitat enhancement',
            involves: 'Marine habitat restoration materials',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/25'
        },
        '25A': {
            typeOfActivity: 'Construction of works',
            purpose: 'Marine infrastructure',
            involves: 'Pontoons and marine structures',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/25A'
        },
        '34': {
            typeOfActivity: 'Construction of works',
            purpose: 'Emergency works',
            involves: 'Emergency coastal protection works',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/34'
        },
        '35': {
            typeOfActivity: 'Removal of a substance or object',
            purpose: 'Environmental protection',
            involves: 'Removal of marine debris and pollutants',
            legislationUrl: 'https://www.legislation.gov.uk/uksi/2011/409/article/35'
        }
    };
    
    return activityMappings[article] || activityMappings['17A']; // fallback to 17A
}

module.exports = function (router) {
    let version = "versions/multiple-sites-v2/";
    let section = "exemption/";

// Route handler for sign-in page to capture article information
router.get('/' + version + section + 'sign-in', function (req, res) {
    // Store article information in session if provided
    if (req.query.article) {
        req.session.data['exemption-article'] = req.query.article;
    }
    // if a user is an org user then store it in the session
    if (req.query.user_type === 'organisation') {
        req.session.data['user_type'] = 'organisation';
    }
    // Store component type if provided (for autocomplete vs radio button selection)
    if (req.query.component_type) {
        req.session.data['component_type'] = req.query.component_type;
    }
    // Store goto parameter if provided (for sign-out -> sign-in flow)
    if (req.query.goto) {
        req.session.data['goto'] = req.query.goto;
    }
    
    // Clear organisation data when user signs in (including when they sign out and come back)
    delete req.session.data['organisation-name'];
    delete req.session.data['changing-organisation'];
    
    res.render(version + section + 'sign-in');
});

// sign-in router
router.post('/' + version + section + 'sign-in-router', function (req, res) {
    // if a user is an org user then redirect to select an org
    if (req.session.data['user_type'] === 'organisation') {
        // Clear the flag to ensure this is treated as a new selection
        delete req.session.data['changing-organisation'];
        
        // Redirect to autocomplete version if component_type is set to autocomplete
        if (req.session.data['component_type'] === 'autocomplete') {
            res.redirect('organisation-selector-autocomplete');
        } else {
            res.redirect('organisation-selector');
        }
    } else {
        // Check if user came from sign-out (goto=home parameter)
        if (req.session.data['goto'] === 'home') {
            // Clear the goto parameter and redirect to home
            delete req.session.data['goto'];
            res.redirect('home');
        } else {
            // Redirect to the project name page for new users
            res.redirect('project-name-start');
        }
    }
});

// organisation selector router
router.post('/' + version + section + 'organisation-selector-router', function (req, res) {
    // Turn off errors by default
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    // Check if the radio button is selected
    if (req.session.data['organisation-name'] === undefined) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('organisation-selector');
    } else {
        // If the user is changing their organisation, redirect to the home page
        if (req.session.data['changing-organisation'] === 'true') {
            // Toggle the alternative project view
            req.session.data['alternativeProjectView'] = req.session.data['alternativeProjectView'] === 'true' ? 'false' : 'true';
            // Reset the flag
            delete req.session.data['changing-organisation'];
            res.redirect('home');
        } else {
            // Check if user came from sign-out (goto=home parameter)
            if (req.session.data['goto'] === 'home') {
                // Clear the goto parameter and redirect to home
                delete req.session.data['goto'];
                res.redirect('home');
            } else {
                // Redirect to the project name page for new users
                res.redirect('project-name-start');
            }
        }
    }
});

// Functions for clearing location data
function clearMapData(session) {
delete session.data['sites-drawn-coordinates'];
}

function clearCoordinateData(session) {
    // Clear circle data
    delete session.data['exemption-enter-the-coordinates-at-the-centre-point-latitude-text-input'];
    delete session.data['exemption-enter-the-coordinates-at-the-centre-point-longitude-text-input'];
    delete session.data['exemption-width-of-site-number-input'];
    
    // Clear square data
    delete session.data['exemption-what-are-the-coordinates-of-the-square-latitude-text-input'];
    delete session.data['exemption-what-are-the-coordinates-of-the-square-longitude-text-input'];
    delete session.data['exemption-width-of-square-number-input'];

    // Clear multiple coordinates data
    for (let i = 1; i <= 5; i++) {
        delete session.data[`coordinates-point-${i}-latitude`];
        delete session.data[`coordinates-point-${i}-longitude`];
    }
}

// Function to clear all manual entry session data
function clearAllManualEntryData(session) {
    // Clear manual entry specific data
    delete session.data['manual-multiple-sites'];
    delete session.data['manual-current-site'];
    
    // Clear activity dates settings
    delete session.data['manual-same-activity-dates'];
    delete session.data['manual-same-activity-description'];
    
    // Clear shared activity dates
    delete session.data['manual-start-date-date-input-day'];
    delete session.data['manual-start-date-date-input-month'];
    delete session.data['manual-start-date-date-input-year'];
    delete session.data['manual-end-date-date-input-day'];
    delete session.data['manual-end-date-date-input-month'];
    delete session.data['manual-end-date-date-input-year'];
    
    // Clear shared activity description
    delete session.data['manual-activity-details-text-area'];
    
    // Clear coordinate entry method and system
    delete session.data['manual-coordinate-entry-method'];
    delete session.data['manual-coordinate-system-radios'];
    
    // Clear Site 1 data
    delete session.data['manual-site-name-text-input'];
    delete session.data['manual-latitude'];
    delete session.data['manual-longitude'];
    delete session.data['manual-site-width'];
    
    // Clear Site 1 multiple coordinates
    for (let i = 1; i <= 5; i++) {
        delete session.data[`manual-coordinates-point-${i}-latitude`];
        delete session.data[`manual-coordinates-point-${i}-longitude`];
    }
    
    // Clear Site 2+ data (sites 2-20)
    for (let siteNum = 2; siteNum <= 20; siteNum++) {
        // Site names
        delete session.data[`manual-site-${siteNum}-name-text-input`];
        
        // Individual dates if different
        delete session.data[`manual-site-${siteNum}-start-date-date-input-day`];
        delete session.data[`manual-site-${siteNum}-start-date-date-input-month`];
        delete session.data[`manual-site-${siteNum}-start-date-date-input-year`];
        delete session.data[`manual-site-${siteNum}-end-date-date-input-day`];
        delete session.data[`manual-site-${siteNum}-end-date-date-input-month`];
        delete session.data[`manual-site-${siteNum}-end-date-date-input-year`];
        
        // Individual descriptions if different
        delete session.data[`manual-site-${siteNum}-activity-details-text-area`];
        
        // Coordinate methods and systems
        delete session.data[`manual-site-${siteNum}-coordinate-entry-method`];
        delete session.data[`manual-site-${siteNum}-coordinate-system-radios`];
        
        // Circular coordinates
        delete session.data[`manual-site-${siteNum}-latitude`];
        delete session.data[`manual-site-${siteNum}-longitude`];
        delete session.data[`manual-site-${siteNum}-site-width`];
        
        // Multiple coordinates
        for (let i = 1; i <= 5; i++) {
            delete session.data[`manual-site-${siteNum}-coordinates-point-${i}-latitude`];
            delete session.data[`manual-site-${siteNum}-coordinates-point-${i}-longitude`];
        }
    }
}

// Function to clear all file upload session data
function clearAllFileUploadData(session) {
    // Clear file upload specific data
    delete session.data['exemption-which-type-of-file-radios'];
    delete session.data['kml-file-upload'];
    
    // Clear activity dates settings for file upload
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    
    // Clear shared activity dates for file upload
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    
    // Clear shared activity description for file upload
    delete session.data['exemption-activity-details-text-area'];
    delete session.data['exemption-same-activity-description-for-sites'];
    
    // Clear any file upload related flags
    delete session.data['hasUploadedFile'];
    delete session.data['fileUploadCount'];
    delete session.data['singleSiteFileUpload'];
}

// Function to comprehensively clear data when changing file upload choices from review page
function clearDataForFileUploadChange(session) {
    // Clear all file upload data
    clearAllFileUploadData(session);
    
    // Clear the current batch and all associated sites
    const currentBatchId = session.data['currentBatchId'];
    if (currentBatchId && session.data['siteBatches']) {
        // Remove the current batch from siteBatches array
        session.data['siteBatches'] = session.data['siteBatches'].filter(batch => batch.id !== currentBatchId);
        
        // Reset the global site counter if this was the only batch
        if (session.data['siteBatches'].length === 0) {
            delete session.data['globalSiteCounter'];
        } else {
            // Recalculate global site counter based on remaining sites
            let maxGlobalNumber = 0;
            session.data['siteBatches'].forEach(batch => {
                batch.sites.forEach(site => {
                    if (site.globalNumber > maxGlobalNumber) {
                        maxGlobalNumber = site.globalNumber;
                    }
                });
            });
            session.data['globalSiteCounter'] = maxGlobalNumber;
        }
    }
    
    // Clear current batch ID
    delete session.data['currentBatchId'];
    
    // Reset file upload count for review page changes to get consistent site generation
    // This function is only called from review page "change" links with clearData=true
    delete session.data['fileUploadCount'];
    
    // Clear coordinate method selection to force user to choose again
    delete session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
    
    // Clear all site-related session flags
    delete session.data['siteDetailsSaved'];
    delete session.data['fromReviewSiteDetails'];
    
    // Clear any return parameters
    delete session.data['returnTo'];
}

// Function to clear all coordinate method session data for fresh start
function clearAllCoordinateMethodData(session) {
    // Clear manual entry data
    clearAllManualEntryData(session);
    
    // Clear file upload data  
    clearAllFileUploadData(session);
    
    // Clear coordinate method selection
    delete session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
    
    // Clear coordinate data from old flow
    clearCoordinateData(session);
    clearMapData(session);
    
    // Clear any error states
    delete session.data['errorthispage'];
    delete session.data['errortypeone'];
    delete session.data['errortypetwo'];
    delete session.data['startdateerror'];
    delete session.data['enddateerror'];
    delete session.data['errors'];
    
    // Clear navigation flags
    delete session.data['fromReviewSiteDetails'];
    delete session.data['siteDetailsSaved'];
    delete session.data['current-site'];
    delete session.data['returnTo'];
}

// Add these new clearing functions
function clearAllLocationData(session) {
    // Clear coordinate data
    clearCoordinateData(session);
    
    // Clear coordinate system
    clearCoordinateSystem(session);
    
    // Clear coordinate type
    clearCoordinateType(session);
    
    // Clear method of providing coordinates
    delete session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
    
    // Clear file upload data
    delete session.data['exemption-which-type-of-file-radios'];
    delete session.data['kml-file-upload'];
    
    // Clear map data
    clearMapData(session);
}

function clearCoordinateSystem(session) {
    delete session.data['exemption-what-coordinate-system-radios'];
    clearCoordinateValues(session);
}

function clearCoordinateType(session) {
    delete session.data['coords-type'];
    delete session.data['exemption-how-do-you-want-to-enter-the-coordinates-radios']; // Clear the selection itself
    delete session.data['previous-coords-entry-method']; // Clear the tracking variable
    clearCoordinateValues(session);
}

function clearCoordinateValues(session) {
    // Clear circle data
    delete session.data['exemption-enter-the-coordinates-at-the-centre-point-latitude-text-input'];
    delete session.data['exemption-enter-the-coordinates-at-the-centre-point-longitude-text-input'];
    delete session.data['exemption-width-of-site-number-input'];
    
    // Clear square data
    delete session.data['exemption-what-are-the-coordinates-of-the-square-latitude-text-input'];
    delete session.data['exemption-what-are-the-coordinates-of-the-square-longitude-text-input'];
    delete session.data['exemption-width-of-square-number-input'];

    // Clear multiple coordinates data
    for (let i = 1; i <= 5; i++) {
        delete session.data[`coordinates-point-${i}-latitude`];
        delete session.data[`coordinates-point-${i}-longitude`];
    }
}

// Function to clear only the current batch when cancelling from review page
function clearCurrentBatchOnly(session) {
    const currentBatchId = session.data['currentBatchId'];
    delete session.data['user_type'];
    
    if (currentBatchId && session.data['siteBatches']) {
        // Find and remove the current batch
        const batchIndex = session.data['siteBatches'].findIndex(batch => batch.id === currentBatchId);
        if (batchIndex !== -1) {
            session.data['siteBatches'].splice(batchIndex, 1);
            
            // Rebuild the global sites array from remaining batches
            session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
        }
    }
    
    // Clear current batch related data
    delete session.data['currentBatchId'];
    
    // Clear session data related to the current entry method
    // Note: We need to be careful here since getCurrentBatch won't work after we removed the batch
    // So we'll clear both types of session data to be safe
    clearAllManualEntryData(session);
    clearAllFileUploadData(session);
    clearAllLocationData(session);
    
    // Clear file upload activity settings
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['previous-activity-description-selection'];
    delete session.data['exemption-activity-details-text-area'];
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    
    // Clear manual entry activity settings
    delete session.data['manual-same-activity-dates'];
    delete session.data['manual-same-activity-description'];
    delete session.data['manual-activity-details-text-area'];
    delete session.data['manual-start-date-date-input-day'];
    delete session.data['manual-start-date-date-input-month'];
    delete session.data['manual-start-date-date-input-year'];
    delete session.data['manual-end-date-date-input-day'];
    delete session.data['manual-end-date-date-input-month'];
    delete session.data['manual-end-date-date-input-year'];
    
    // Clear coordinate method selection for new batch
    delete session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
    
    // Clear navigation and state flags
    delete session.data['fromReviewSiteDetails'];
    delete session.data['current-site'];
    delete session.data['manual-current-site'];
    delete session.data['returnTo'];
    
    // Update status based on remaining batches
    if (!session.data['siteBatches'] || session.data['siteBatches'].length === 0) {
        // No batches remain - reset to not started
        session.data['exempt-information-3-status'] = 'not-started';
        delete session.data['siteDetailsSaved'];
        delete session.data['sites'];
        delete session.data['siteBatches'];
        delete session.data['globalSiteCounter'];
        delete session.data['hasUploadedFile'];
    } else {
        // Other batches still exist - keep status as in-progress or completed
        // Don't change the status as other batches may be saved
    }
}

// Function to clear all site details data when cancelling to task list
function clearAllSiteDetails(session) {
    // Clear batch system data
    delete session.data['siteBatches'];
    delete session.data['sites'];
    delete session.data['currentBatchId'];
    delete session.data['globalSiteCounter'];
    delete session.data['user_type'];
    
    // Clear file upload tracking
    delete session.data['hasUploadedFile'];
    
    // Clear site location data
    clearAllLocationData(session);
    
    // Clear file upload specific data
    clearAllFileUploadData(session);
    
    // Clear manual entry specific data
    clearAllManualEntryData(session);
    
    // Clear activity date settings (both file upload and manual entry)
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    delete session.data['manual-same-activity-dates'];
    
    // Clear shared activity dates (both file upload and manual entry)
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    delete session.data['manual-start-date-date-input-day'];
    delete session.data['manual-start-date-date-input-month'];
    delete session.data['manual-start-date-date-input-year'];
    delete session.data['manual-end-date-date-input-day'];
    delete session.data['manual-end-date-date-input-month'];
    delete session.data['manual-end-date-date-input-year'];
    
    // Clear activity description settings (both file upload and manual entry)
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['previous-activity-description-selection'];
    delete session.data['manual-same-activity-description'];
    
    // Clear shared activity description (both file upload and manual entry)
    delete session.data['exemption-activity-details-text-area'];
    delete session.data['manual-activity-details-text-area'];
    
    // Clear coordinate method selection
    delete session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
    
    // Clear any error states
    delete session.data['startdateerror'];
    delete session.data['enddateerror'];
    delete session.data['errorthispage'];
    delete session.data['errortypeone'];
    delete session.data['errortypetwo'];
    delete session.data['errors'];
    
    // Clear navigation flags
    delete session.data['fromReviewSiteDetails'];
    delete session.data['siteDetailsSaved'];
    delete session.data['current-site'];
    delete session.data['manual-current-site'];
    delete session.data['returnTo'];
    delete session.data['site'];
    delete session.data['return'];
    
    // Reset task status
    delete session.data['exempt-information-3-status'];
}

// Function to clear all data after method of providing site location
function clearDataAfterLocationMethod(session) {
    // Clear file type selection
    delete session.data['exemption-which-type-of-file-radios'];
    
    // Clear file upload data
    delete session.data['kml-file-upload'];
    
    // Clear activity date settings
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    
    // Clear shared activity dates
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    
    // Clear activity description settings
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['previous-activity-description-selection'];
    
    // Clear shared activity description
    delete session.data['exemption-activity-details-text-area'];
}

// Function to clear all data after file type selection
function clearDataAfterFileType(session) {
    // Clear file upload data
    delete session.data['kml-file-upload'];
    
    // Clear activity date settings
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    
    // Clear shared activity dates
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    
    // Clear activity description settings
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['previous-activity-description-selection'];
    
    // Clear shared activity description
    delete session.data['exemption-activity-details-text-area'];
}

// Function to clear all data after file upload
function clearDataAfterFileUpload(session) {
    // Clear activity date settings
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    
    // Clear shared activity dates
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    
    // Clear activity description settings
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['previous-activity-description-selection'];
    
    // Clear shared activity description
    delete session.data['exemption-activity-details-text-area'];
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Single-site file upload journey entry point
// DIRECT LINK FROM INDEX PAGE FOR 1-SITE FILE UPLOAD TESTING
//////////////////////////////////////////////////////////////////////////////////////////////

router.get('/' + version + section + 'single-site-file-upload-start', function (req, res) {
    // Clear all session data for a fresh start
    clearAllSiteDetails(req.session);
    
    // Set up session for single-site file upload
    req.session.data['exemption-project-name-text-input'] = 'Worthing sea sample';
    req.session.data['exempt-information-1-status'] = 'completed';
    req.session.data['headerNameExemption'] = 'Apply for a marine licence';
    req.session.data['exemption'] = 'sample-notification';
    
    // Force single-site generation by setting upload count to 1
    // This will become 2 after increment, triggering 1-site creation
    req.session.data['fileUploadCount'] = 1;
    
    // Set flag specifically for single site file upload journey
    req.session.data['singleSiteFileUpload'] = true;
    
    // Set coordinate method to file upload
    req.session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'] = 'Upload a file with the coordinates of the site';
    
    // Go directly to file type selection
    res.redirect('which-type-of-file');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Project name start
// NOT THE ONE IN THE TASK LIST - SEE BELOW FOR THAT ONE
// TEXT ENTRY
//////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'project-name-start-router', function (req, res) {
    // Turn off errors by default
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    // Check if the text input (Project name) is blank
    const projectTitle = req.session.data['exemption-project-name-text-input'];
    if (!projectTitle || projectTitle.trim() === "") {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
    }

    // Redirect based on errors
    if (req.session.data['errorthispage'] === "true") {
        res.redirect('project-name-start');
    } else {
        // Set the status to completed
        req.session.data['exempt-information-1-status'] = 'completed';
        
        // Check if we need to return to check answers
        if (req.session.data['camefromcheckanswers'] === 'true') {
            req.session.data['camefromcheckanswers'] = false;
            res.redirect('check-answers#project-name');
        } else {
            res.redirect('task-list');
        }
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Project name
// NOT THE OPENING ONE 
// TEXT ENTRY
//////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'project-name-router', function (req, res) {
    // Turn off errors by default
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    // Check if the text input (Project name) is blank
    const projectTitle = req.session.data['exemption-project-name-text-input'];
    if (!projectTitle || String(projectTitle).trim() === "") {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
    }

    // Redirect based on errors
    if (req.session.data['errorthispage'] === "true") {
        res.redirect('project-name');
    } else {
        // Set the status to completed
        req.session.data['exempt-information-1-status'] = 'completed';
        
        // Check if we need to return to check answers
        if (req.session.data['camefromcheckanswers'] === 'true') {
            req.session.data['camefromcheckanswers'] = false;
            res.redirect('check-answers-multiple-sites');
        } else {
            res.redirect('task-list');
        }
    }
});

router.get('/' + version + section + 'project-name', function (req, res) {
    req.session.data['headerNameExemption'] = 'Apply for a marine licence';
    res.render(version + section + 'project-name');
});

///////////////////////////////////////////////////////////////////////////////////////////////
// Activity dates
// DATE ENTRY -  both start and end
//////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'activity-dates-router', function (req, res) {
    // Reset separate error flags
    req.session.data['startdateerror'] = "false";
    req.session.data['enddateerror'] = "false";

    // Retrieve the start date values
    const startDay   = req.session.data['exemption-start-date-date-input-day'];
    const startMonth = req.session.data['exemption-start-date-date-input-month'];
    const startYear  = req.session.data['exemption-start-date-date-input-year'];

    // Retrieve the end date values
    const endDay   = req.session.data['exemption-end-date-date-input-day'];
    const endMonth = req.session.data['exemption-end-date-date-input-month'];
    const endYear  = req.session.data['exemption-end-date-date-input-year'];

    // Check if the start date is missing any field
    if (!startDay || !startMonth || !startYear) {
        req.session.data['startdateerror'] = "true";
    }

    // Check if the end date is missing any field
    if (!endDay || !endMonth || !endYear) {
        req.session.data['enddateerror'] = "true";
    }

    // If either date is incomplete, redirect back to show the errors
    if (req.session.data['startdateerror'] === "true" || req.session.data['enddateerror'] === "true") {
        return res.redirect('activity-dates');
    }
    
    // Save dates to current batch metadata if we have one
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings) {
        currentBatch.settings.sharedStartDate = {
            day: startDay,
            month: startMonth,
            year: startYear
        };
        currentBatch.settings.sharedEndDate = {
            day: endDay,
            month: endMonth,
            year: endYear
        };
    }
    
    // Check if we're coming from review-site-details page
    const returnTo = req.session.data['returnTo'];
    if (returnTo === 'review-site-details') {
        delete req.session.data['returnTo']; // Clear the return flag
        
        // Look for anchor in referrer URL
        const referer = req.headers.referer || '';
        const hashPosition = referer.indexOf('#');
        
        if (hashPosition > -1) {
            // Extract the anchor and redirect with it
            const anchor = referer.substring(hashPosition);
            return res.redirect('review-site-details' + anchor);
        }
        
        return res.redirect('review-site-details');
    }

    // Default behavior - go to the activity description question
    res.redirect('same-activity-description');
});

router.get('/' + version + section + 'activity-dates', function (req, res) {
    // Check if we're returning from review-site-details
    if (req.query.returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    res.render(version + section + 'activity-dates');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Activity details
// TEXT ENTRY (TEXTAREA)
/////////////////////////////////////////////////////////////////////////////////////////////

// Fix the route for activity-details GET request
router.get('/' + version + section + 'activity-details', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errors'] = [];

    // Check if we're returning from review-site-details
    if (req.query.returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }

    res.render(version + section + 'activity-details');
});

// Fix the route handler for activity details POST request
router.post('/' + version + section + 'activity-details-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const activityDetails = req.session.data['exemption-activity-details-text-area'];
    if (!activityDetails || activityDetails.trim() === "") {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        return res.redirect('activity-details');
    }

    // Save description to current batch metadata if we have one
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings) {
        currentBatch.settings.sharedDescription = activityDetails;
    }

    // Check if we're coming from review-site-details page
    const returnTo = req.session.data['returnTo'];
    if (returnTo === 'review-site-details') {
        delete req.session.data['returnTo']; // Clear the return flag
        
        // Look for anchor in referrer URL
        const referer = req.headers.referer || '';
        const hashPosition = referer.indexOf('#');
        
        if (hashPosition > -1) {
            // Extract the anchor and redirect with it
            const anchor = referer.substring(hashPosition);
            return res.redirect('review-site-details' + anchor);
        }
        
        return res.redirect('review-site-details');
    }

    // Default behavior - go to review-site-details
    res.redirect('review-site-details');
});

// Maintain the existing about-your-activity-router for backward compatibility
router.post('/' + version + section + 'about-your-activity-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const activityDetails = req.session.data['exemption-activity-details-text-area'];
    if (!activityDetails || activityDetails.trim() === "") {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('about-your-activity');
    } else {
        // If the user came from check answers, return there
        if (req.session.data['camefromcheckanswers'] === 'true') {
            req.session.data['camefromcheckanswers'] = false;
            res.redirect('check-answers#about-your-activity');
        } else {
            res.redirect('start-date');
        }
    }
});


//////////////////////////////////////////////////////////////////////////////////////////////
// Public Register
// RADIO BUTTONS WITH CONDITIONAL TEXTAREA
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'public-register-router', function (req, res) {
    // Reset error states
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errortypetwo'] = "false";

    // Clear text area if user changes from Yes to No
    if (req.session.data['exemption-public-register-radios'] === 'No') {
        delete req.session.data['exemption-public-register-text-area'];
    }

    // Check if the radio option is selected
    if (
        req.session.data['exemption-public-register-radios'] == undefined ||
        req.session.data['exemption-public-register-radios'].trim() == ""
    ) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('public-register');
    } 
    // If "Yes" is selected, ensure the textarea is not empty
    else if (
        req.session.data['exemption-public-register-radios'] == "Yes" &&
        (req.session.data['exemption-public-register-text-area'] == undefined ||
         req.session.data['exemption-public-register-text-area'].trim() == "")
    ) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypetwo'] = "true";
        res.redirect('public-register');
    } else {
       // Set the status to completed
       req.session.data['exempt-information-4-status'] = 'completed';
       
       // Check if we need to return to check answers
       if (req.session.data['camefromcheckanswers'] === 'true') {
            req.session.data['camefromcheckanswers'] = false;
            res.redirect('check-answers-multiple-sites');
        } else {
            res.redirect('task-list');
        }
    }
});

// Map router
router.post('/' + version + section + 'map-router', function (req, res) {
    // Set siteTitle
    req.session.data['siteTitle'] = 'review';
    res.redirect('review-location');
});


//////////////////////////////////////////////////////////////////////////////////////////////
// Check answers
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'check-answers-router', function (req, res) {
    req.session.data['applicationSubmitted'] = 'true';
    // Redirect to review location page
    res.redirect('confirmation');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Check answers multiple sites
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'check-answers-router', function (req, res) {
    req.session.data['applicationSubmitted'] = 'true';
    // Redirect to confirmation page
    res.redirect('confirmation');
});


// Add route handler for check-answers-multiple-sites page
router.get('/' + version + section + 'check-answers-multiple-sites', function (req, res) {
    // Clear site details journey flag - user has left site details section
    delete req.session.data['inSiteDetailsJourney'];
    
    // Ensure the site details are marked as saved when reaching check answers
    req.session.data['siteDetailsSaved'] = true;
    
    // Render the page
    res.render(version + section + 'check-answers-multiple-sites');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Delete project router
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'delete-router', function (req, res) {
    // Get the project to delete from the query parameter
    const projectToDelete = req.query.project;
    
    if (projectToDelete === 'user') {
        // Delete the user's project
        req.session.data['userProjectDeleted'] = 'true';
    } else if (projectToDelete === 'tower-bridge') {
        // Delete the Tower Bridge project
        req.session.data['towerBridgeProjectDeleted'] = 'true';
    } else {
        // Fallback to old behavior for backward compatibility
        req.session.data['deleteProject'] = 'true';
    }
    
    // Redirect to Your projects page
    res.redirect('home');
});

// Home page initialization - ensure project deletion flags are properly set
router.get('/' + version + section + 'home', function (req, res) {
    // Clear site details journey flag - user has left site details section
    delete req.session.data['inSiteDetailsJourney'];
    
    // Initialize flags if they don't exist already
    if (req.session.data['userProjectDeleted'] === undefined) {
        req.session.data['userProjectDeleted'] = 'false';
    }
    
    if (req.session.data['towerBridgeProjectDeleted'] === undefined) {
        req.session.data['towerBridgeProjectDeleted'] = 'false';
    }
    
    if (req.session.data['deleteProject'] === undefined) {
        req.session.data['deleteProject'] = 'false';
    }
    
    // Pass the URL parameter directly to the template for immediate effect
    const deleteProjectsParam = req.query['delete-projects'] === 'true';
    
    // Render the home page with additional context
    res.render(version + section + 'home', {
        deleteProjectsParam: deleteProjectsParam
    });
});

// Manual site name router
router.post('/' + version + section + 'manual-site-name-router', function (req, res) {
    // Reset error flags
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    
    // Get the site number
    const siteNum = req.session.data['site'];
    
    // Validate input
    if (!req.session.data['manual-site-name-input'] || req.session.data['manual-site-name-input'].trim() === '') {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('manual-site-name');
    } else {
        // Save the site name to the site-specific variable
        req.session.data['site-' + siteNum + '-name'] = req.session.data['manual-site-name-input'];
        
        // Clear the temporary input field
        req.session.data['manual-site-name-input'] = '';
        
        // Redirect back to the review site details page
        const returnSection = req.session.data['return'] || '';
        res.redirect('review-site-details#site-' + siteNum + '-details');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Delete site confirmation
// CONFIRMATION PAGE
/////////////////////////////////////////////////////////////////////////////////////////////

router.get('/' + version + section + 'delete-site', function (req, res) {
    // Make site parameter available to the template
    const siteIndex = parseInt(req.query.site) || 1;
    const returnTo = req.query.return || 'review-site-details';
    
    // Store these values in the session for use in the POST handler
    req.session.data['site'] = siteIndex;
    req.session.data['returnTo'] = returnTo;
    
    // Render the delete site confirmation page
    res.render(version + section + 'delete-site');
});

router.post('/' + version + section + 'delete-site-router', function (req, res) {
    // Get the global site number from the session (1-based)
    const globalSiteNumber = parseInt(req.session.data['site']) || 1;
    
    // Get the return page from the session
    const returnTo = req.session.data['returnTo'] || 'review-site-details';
    
    // Find the site by global number
    const siteToDelete = findSiteByGlobalNumber(req.session, globalSiteNumber);
    let batchWillBeEmpty = false;
    
    if (siteToDelete) {
        // Remove from the batch
        if (req.session.data['siteBatches'] && siteToDelete.batchId) {
            const batch = req.session.data['siteBatches'].find(b => b.id === siteToDelete.batchId);
            if (batch) {
                const batchSiteIndex = batch.sites.findIndex(s => s.globalNumber === globalSiteNumber);
                if (batchSiteIndex !== -1) {
                    // Check if this is the last site in the batch before removing it
                    batchWillBeEmpty = (batch.sites.length === 1);
                    batch.sites.splice(batchSiteIndex, 1);
                }
            }
        }
        
        // NEW: Renumber all remaining sites
        renumberSitesAfterDeletion(req.session, globalSiteNumber);
    }
    
    // Redirect logic: handle different scenarios based on return location and batch state
    if (returnTo === 'manual-entry-review' && batchWillBeEmpty) {
        // Manual entry review with last site deleted - reset to fresh start
        clearAllSiteDetails(req.session);
        req.session.data['exempt-information-3-status'] = 'not-started';
        res.redirect('task-list');
    } else if (returnTo === 'manual-entry-review') {
        res.redirect('manual-entry/review-site-details#site-' + globalSiteNumber + '-details');
    } else if (returnTo === 'review-site-details') {
        res.redirect('review-site-details#site-' + globalSiteNumber + '-details');
    } else if (returnTo === 'check-answers-multiple-sites') {
        res.redirect('check-answers-multiple-sites');
    } else {
        // Default fallback
        res.redirect('review-site-details');
    }
});

// When returning to site-details from task list, initialize the flow
router.get('/' + version + section + 'site-details', function (req, res) {
    // Set origin context - this is always from task list
    setOriginContext(req.session, 'task-list');
    
    // Set flag to indicate user is in site details journey
    req.session.data['inSiteDetailsJourney'] = true;
    
    // Set the flag to false when starting the site details journey
    req.session.data['siteDetailsSaved'] = false;
    
    // Initialize review state for new journey
    req.session.data['reviewPageVisited'] = false;
    req.session.data['reviewPageSaved'] = false;
    req.session.data['isEditingFromReview'] = false;
    
    logCancelState(req.session, 'site-details GET - new journey start');
    
    // Render the page
    res.render(version + section + 'site-details');
});

// Route handler for review-site-details
router.get('/' + version + section + 'review-site-details', function (req, res) {
    // Validate method switch backup for edge cases
    validateMethodSwitchBackup(req.session);
    
    // Set journey flag - user is in site details journey when on review page
    req.session.data['inSiteDetailsJourney'] = true;
    
    // Set origin context based on how user arrived
    if (req.query.camefromcheckanswers === 'true') {
        setOriginContext(req.session, 'check-answers');
        req.session.data['camefromcheckanswers'] = 'true';
    } else if (req.query.batchId) {
        setOriginContext(req.session, 'task-list');
    } else if (req.query.origin) {
        // Explicit origin parameter
        setOriginContext(req.session, req.query.origin);
    }
    // Note: If no origin specified, preserve existing context
    
    // Track review page visit
    updateReviewState(req.session, 'visited');
    
    // If we have a site query parameter, set the active site
    if (req.query.site) {
        req.session.data['site'] = req.query.site;
    }
    // If we have a batchId query parameter, set it as current batch
    if (req.query.batchId) {
        req.session.data['currentBatchId'] = req.query.batchId;
        // Mark that user is editing a previously saved batch
        updateReviewState(req.session, 'saved');
    }
    
    // If we're reviewing a specific batch, populate session data from batch settings
    if (req.query.batchId) {
        const currentBatch = getCurrentBatch(req.session);
        if (currentBatch && currentBatch.settings) {
            // Populate activity settings from batch
            req.session.data['exemption-same-activity-dates-for-sites'] = currentBatch.settings.sameActivityDates;
            req.session.data['exemption-same-activity-description-for-sites'] = currentBatch.settings.sameActivityDescription;
            
            // Populate file upload data from batch (for file upload batches)
            if (currentBatch.entryMethod === 'file-upload') {
                // Set file upload flag
                req.session.data['hasUploadedFile'] = true;
                
                // Set file type if available
                if (currentBatch.settings.fileType) {
                    req.session.data['exemption-which-type-of-file-radios'] = currentBatch.settings.fileType;
                }
            }
            
            // Populate shared dates from batch
            if (currentBatch.settings.sharedStartDate) {
                req.session.data['exemption-start-date-date-input-day'] = currentBatch.settings.sharedStartDate.day;
                req.session.data['exemption-start-date-date-input-month'] = currentBatch.settings.sharedStartDate.month;
                req.session.data['exemption-start-date-date-input-year'] = currentBatch.settings.sharedStartDate.year;
            }
            
            if (currentBatch.settings.sharedEndDate) {
                req.session.data['exemption-end-date-date-input-day'] = currentBatch.settings.sharedEndDate.day;
                req.session.data['exemption-end-date-date-input-month'] = currentBatch.settings.sharedEndDate.month;
                req.session.data['exemption-end-date-date-input-year'] = currentBatch.settings.sharedEndDate.year;
            }
            
            // Populate shared description from batch
            if (currentBatch.settings.sharedDescription) {
                req.session.data['exemption-activity-details-text-area'] = currentBatch.settings.sharedDescription;
            }
            
            // Populate site-specific data from batch sites
            if (currentBatch.sites) {
                currentBatch.sites.forEach((site, index) => {
                    const siteNum = index + 1;
                    
                    // Populate site name using the site-name-text-input pattern for file uploads
                    req.session.data[`site-${siteNum}-name`] = site.name;
                    
                    // Populate site-specific dates if they're different for each site
                    if (currentBatch.settings.sameActivityDates === 'No') {
                        if (site.startDate) {
                            req.session.data[`site-${siteNum}-start-date-day`] = site.startDate.day;
                            req.session.data[`site-${siteNum}-start-date-month`] = site.startDate.month;
                            req.session.data[`site-${siteNum}-start-date-year`] = site.startDate.year;
                        }
                        if (site.endDate) {
                            req.session.data[`site-${siteNum}-end-date-day`] = site.endDate.day;
                            req.session.data[`site-${siteNum}-end-date-month`] = site.endDate.month;
                            req.session.data[`site-${siteNum}-end-date-year`] = site.endDate.year;
                        }
                    }
                    
                    // Populate site-specific descriptions if they're different for each site
                    if (currentBatch.settings.sameActivityDescription === 'No') {
                        req.session.data[`site-${siteNum}-activity-description`] = site.description;
                    }
                });
            }
        }
    }
    
    // Set a flag to indicate we're coming from review-site-details
    req.session.data['fromReviewSiteDetails'] = 'true';
    // Only pass the current batch's sites to the template
    let sites = [];
    if (typeof getCurrentBatch === 'function') {
        const batch = getCurrentBatch(req.session);
        if (batch) {
            sites = batch.sites;
        }
    }
    
    // Use the regular review page for all site counts (single or multiple)
    res.render(version + section + 'review-site-details', { 
        sites,
        data: req.session.data 
    });
});

//////////////////////////////////////////////////////////////////////////////////////////////
// How do you want to provide the coordinates?
// PAGE OF RADIO BUTTONS
/////////////////////////////////////////////////////////////////////////////////////////////

// GET route handler for the "How do you want to provide coordinates" page
router.get('/' + version + section + 'how-do-you-want-to-provide-the-coordinates', function (req, res) {
    // Clear error states when loading the page
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errors'] = [];
    
    // Track origin and review state
    if (req.query.returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'coordinates page - editing from review');
    } else if (!req.query.returnTo && !req.query.camefromcheckanswers) {
        // Starting a new journey - set task list origin if not already set
        if (!req.session.data['cancelOrigin']) {
            setOriginContext(req.session, 'task-list');
        }
        
        // Initialize review state for new journey
        req.session.data['reviewPageVisited'] = false;
        req.session.data['reviewPageSaved'] = false;
        req.session.data['isEditingFromReview'] = false;
        
        // Only clear data if starting a truly new journey (not from check answers or review)
        req.session.data['siteDetailsSaved'] = false;
        
        // Clear file upload data for a fresh start BUT preserve fileUploadCount for sequence tracking
        const preservedUploadCount = req.session.data['fileUploadCount'];
        clearAllFileUploadData(req.session);
        if (preservedUploadCount) {
            req.session.data['fileUploadCount'] = preservedUploadCount;
        }
        
        // Also clear the coordinate method selection so user starts fresh
        delete req.session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
        
        // Clear current batch ID so we can start a fresh batch
        delete req.session.data['currentBatchId'];
        
        logCancelState(req.session, 'coordinates page - new journey');
    }
    
    res.render(version + section + 'how-do-you-want-to-provide-the-coordinates');
});

router.post('/' + version + section + 'how-do-you-want-to-provide-the-coordinates-router', function (req, res) {
    // Validate method switch backup for edge cases
    validateMethodSwitchBackup(req.session);
    
    // Turn errors off by default
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const selection = req.session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];

    if (!selection) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('how-do-you-want-to-provide-the-coordinates');
        return;
    }

    // Determine if user is actually changing method (only clear data if they are)
    const currentBatch = getCurrentBatch(req.session);
    const currentMethod = currentBatch ? currentBatch.entryMethod : null;
    const newMethod = selection === "Upload a file with the coordinates of the site" ? "file-upload" : "manual-entry";
    
    // Only clear data if user is changing to a different method
    if (currentMethod && currentMethod !== newMethod) {
        // Create backup before clearing
        createMethodSwitchBackup(req.session, `switching from ${currentMethod} to ${newMethod}`);
        
        // User is changing methods - clear current batch and start fresh
        if (newMethod === "manual-entry") {
            // Switching to manual entry - clear file upload data and batch
            clearDataForFileUploadChange(req.session);
        } else {
            // Switching to file upload - clear manual entry data and batch
            clearCurrentBatchSafely(req.session);
            clearAllManualEntryData(req.session);
        }
    } else if (!currentMethod) {
        // No current method - this is a fresh start, just clear opposing method data
        switch(selection) {
            case "Enter the coordinates of the site manually":
                // Clear any stale file upload data
                delete req.session.data['exemption-which-type-of-file-radios'];
                delete req.session.data['kml-file-upload'];
                req.session.data['manual-multiple-sites'] = '';
                break;
            case "Upload a file with the coordinates of the site":
                // Clear any stale manual entry data
                clearAllManualEntryData(req.session);
                break;
        }
    }
    // If currentMethod === newMethod, don't clear anything - user is staying with same method

    // Check if we're returning to review page
    if (req.session.data['fromReviewSiteDetails'] === 'true' && currentMethod === newMethod) {
        // User didn't actually change method - return to review page
        delete req.session.data['fromReviewSiteDetails'];
        res.redirect('review-site-details');
        return;
    }

    // Route based on selection for new journeys or actual method changes
    switch(selection) {
        case "Enter the coordinates of the site manually":
            res.redirect('manual-entry/does-your-project-involve-more-than-one-site');
            break;
        case "Upload a file with the coordinates of the site":
            res.redirect('which-type-of-file');
            break;
        default:
            res.redirect('how-do-you-want-to-provide-the-coordinates');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Which type of file do you want to upload?
// PAGE OF RADIO BUTTONS
/////////////////////////////////////////////////////////////////////////////////////////////

// GET route handler for the "Which type of file" page
router.get('/' + version + section + 'which-type-of-file', function (req, res) {
    // Clear error states when loading the page
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errors'] = [];
    
    // Check if we're returning from review-site-details
    if (req.query.returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    res.render(version + section + 'which-type-of-file');
});

router.post('/' + version + section + 'which-type-of-file-router', function (req, res) {
    // Turn errors off by default
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const selection = req.session.data['exemption-which-type-of-file-radios'];

    if (!selection) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('which-type-of-file');
        return;
    }

    // Check if user is actually changing file type (only clear data if they are)
    const currentBatch = getCurrentBatch(req.session);
    const currentFileType = currentBatch && currentBatch.settings ? currentBatch.settings.fileType : null;
    
    // Check if we're returning to review page with no actual change
    if (req.session.data['fromReviewSiteDetails'] === 'true' && currentFileType === selection) {
        // User didn't actually change file type - return to review page
        delete req.session.data['fromReviewSiteDetails'];
        res.redirect('review-site-details');
        return;
    }
    
    // Only clear data if user is changing to a different file type
    if (currentFileType && currentFileType !== selection) {
        // User is changing file type - clear current batch and start fresh
        clearDataForFileTypeChange(req.session);
        // IMPORTANT: Restore the new file type selection after clearing
        req.session.data['exemption-which-type-of-file-radios'] = selection;
    }

    // Route based on selection for new journeys or actual changes
    switch(selection) {
        case "KML":
            res.redirect('upload-file');
            break;
        case "Shapefile":
            res.redirect('upload-file');
            break;
        default:
            res.redirect('which-type-of-file');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Upload KML File
// FILE UPLOAD PAGE
/////////////////////////////////////////////////////////////////////////////////////////////

// GET route handler for the "Upload file" page
router.get('/' + version + section + 'upload-file', function (req, res) {
    // Clear error states when loading the page
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errors'] = [];
    
    // Check if we're returning from review-site-details
    if (req.query.returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    res.render(version + section + 'upload-file');
});

// Batch handling functions
function initializeBatch(session, entryMethod) {
    const batchId = Date.now().toString(); // Unique batch ID
    const batch = {
        id: batchId,
        entryMethod: entryMethod,
        createdAt: new Date().toISOString(),
        sites: [],
        startingGlobalNumber: (session.data['globalSiteCounter'] || 0) + 1  // Store the first site number this batch will use
    };
    
    // Initialize batches array if it doesn't exist or isn't an array
    if (!Array.isArray(session.data['siteBatches'])) {
        session.data['siteBatches'] = [];
    }
    
    // Add the new batch
    session.data['siteBatches'].push(batch);
    
    // Set current batch ID
    session.data['currentBatchId'] = batchId;
    
    return batchId;
}

function getCurrentBatch(session) {
    const batchId = session.data['currentBatchId'];
    if (!batchId || !session.data['siteBatches']) {
        return null;
    }
    
    return session.data['siteBatches'].find(batch => batch.id === batchId);
}

function addSiteToBatch(session, siteData) {
    const batch = getCurrentBatch(session);
    if (!batch) {
        return false;
    }
    
    // Initialize global site counter if it doesn't exist
    if (!session.data['globalSiteCounter']) {
        session.data['globalSiteCounter'] = 0;
    }
    
    // Assign global site number
    session.data['globalSiteCounter']++;
    siteData.globalNumber = session.data['globalSiteCounter'];
    
    // Add batch metadata to site
    siteData.batchId = batch.id;
    siteData.entryMethod = batch.entryMethod;
    siteData.addedAt = new Date().toISOString();
    
    // Add to batch's sites array
    batch.sites.push(siteData);
    
    // Rebuild global sites array from all batches to prevent duplicates
    if (!session.data['siteBatches']) {
        session.data['sites'] = [];
    } else {
        session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
    }
    
    return true;
}

function getSitesByBatch(session, batchId) {
    if (!session.data['siteBatches']) {
        return [];
    }
    
    const batch = session.data['siteBatches'].find(b => b.id === batchId);
    return batch ? batch.sites : [];
}

function getAllSites(session) {
    if (!session.data['siteBatches']) {
        return [];
    }
    
    // Flatten all sites from all batches
    return session.data['siteBatches'].flatMap(batch => batch.sites);
}

// Helper function to find a site by global number
function findSiteByGlobalNumber(session, globalNumber) {
    const allSites = getAllSites(session);
    return allSites.find(site => site.globalNumber === parseInt(globalNumber));
}

// Helper function to get the batch-relative position of a site by global number
function getBatchRelativePosition(session, globalNumber) {
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch || !currentBatch.sites) {
        return 1;
    }
    
    const siteIndex = currentBatch.sites.findIndex(site => site.globalNumber === parseInt(globalNumber));
    return siteIndex !== -1 ? siteIndex + 1 : 1;
}

// Function to renumber all sites after deletion
function renumberSitesAfterDeletion(session, deletedGlobalNumber) {
    console.log('=== RENUMBERING SITES AFTER DELETION ===');
    console.log('Deleted site number:', deletedGlobalNumber);
    
    // 1. Renumber sites in all batches
    if (session.data['siteBatches']) {
        session.data['siteBatches'].forEach(batch => {
            console.log('Processing batch:', batch.id);
            batch.sites.forEach(site => {
                if (site.globalNumber > deletedGlobalNumber) {
                    const oldNumber = site.globalNumber;
                    site.globalNumber--;
                    console.log(`Renumbered site from ${oldNumber} to ${site.globalNumber}`);
                }
            });
        });
    }
    
    // 2. Rebuild global sites array
    session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
    
    // 3. Update global site counter
    if (session.data['globalSiteCounter']) {
        session.data['globalSiteCounter']--;
        console.log('Updated globalSiteCounter to:', session.data['globalSiteCounter']);
    }
    
    console.log('=== RENUMBERING COMPLETE ===');
}

// ==============================================================================================
// METHOD SWITCH DATA PRESERVATION SYSTEM
// ==============================================================================================

/**
 * Creates a backup of current batch and session data before method switching
 * @param {Object} session - Express session object
 * @param {String} reason - Reason for backup (for debugging)
 */
function createMethodSwitchBackup(session, reason) {
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch) {
        console.log(`🔄 METHOD SWITCH: No current batch to backup for ${reason}`);
        return;
    }
    
    console.log(`🔄 METHOD SWITCH: Creating backup for ${reason}, batch ${currentBatch.id}`);
    
    // Create deep copy backup
    session.data['methodSwitchBackup'] = {
        reason: reason,
        timestamp: Date.now(),
        originalMethod: currentBatch.entryMethod,
        batch: JSON.parse(JSON.stringify(currentBatch)), // Deep copy
        sessionData: captureMethodSessionData(session, currentBatch.entryMethod),
        originalReviewState: {
            reviewPageVisited: session.data['reviewPageVisited'],
            reviewPageSaved: session.data['reviewPageSaved'],
            isEditingFromReview: session.data['isEditingFromReview'],
            cancelOrigin: session.data['cancelOrigin']
        }
    };
    
    console.log(`✅ METHOD SWITCH: Backup created for ${currentBatch.entryMethod} method`);
}

/**
 * Captures session data specific to a method for backup
 * @param {Object} session - Express session object  
 * @param {String} method - 'manual-entry' or 'file-upload'
 * @returns {Object} - Captured session data
 */
function captureMethodSessionData(session, method) {
    const captured = {};
    
    if (method === 'manual-entry') {
        // Capture manual entry session data
        const manualKeys = [
            'manual-multiple-sites',
            'manual-same-activity-dates', 
            'manual-same-activity-description',
            'manual-start-date-date-input-day',
            'manual-start-date-date-input-month', 
            'manual-start-date-date-input-year',
            'manual-end-date-date-input-day',
            'manual-end-date-date-input-month',
            'manual-end-date-date-input-year',
            'manual-activity-details-text-area'
        ];
        
        manualKeys.forEach(key => {
            if (session.data[key] !== undefined) {
                captured[key] = session.data[key];
            }
        });
    } else if (method === 'file-upload') {
        // Capture file upload session data
        const fileKeys = [
            'exemption-which-type-of-file-radios',
            'hasUploadedFile',
            'exemption-same-activity-dates-for-sites',
            'exemption-same-activity-description-for-sites', 
            'exemption-start-date-date-input-day',
            'exemption-start-date-date-input-month',
            'exemption-start-date-date-input-year',
            'exemption-end-date-date-input-day',
            'exemption-end-date-date-input-month', 
            'exemption-end-date-date-input-year',
            'exemption-activity-details-text-area'
        ];
        
        fileKeys.forEach(key => {
            if (session.data[key] !== undefined) {
                captured[key] = session.data[key];
            }
        });
    }
    
    return captured;
}

/**
 * Restores backed up method data and returns user to original review page
 * @param {Object} session - Express session object
 * @returns {String|null} - Redirect URL or null if no backup
 */
function restoreMethodSwitchBackup(session) {
    const backup = session.data['methodSwitchBackup'];
    if (!backup) {
        console.log('🔄 METHOD SWITCH: No backup found to restore');
        return null;
    }
    
    console.log(`🔄 METHOD SWITCH: Restoring backup for ${backup.originalMethod} method`);
    
    // Restore the batch to siteBatches array
    if (!Array.isArray(session.data['siteBatches'])) {
        session.data['siteBatches'] = [];
    }
    
    // Add restored batch back
    session.data['siteBatches'].push(backup.batch);
    session.data['currentBatchId'] = backup.batch.id;
    
    // Restore method-specific session data
    Object.keys(backup.sessionData).forEach(key => {
        session.data[key] = backup.sessionData[key];
    });
    
    // Restore review state - but reset saved state so user can cancel with warning
    session.data['reviewPageVisited'] = backup.originalReviewState.reviewPageVisited;
    session.data['reviewPageSaved'] = false; // Reset to false so user gets cancel warning
    session.data['isEditingFromReview'] = backup.originalReviewState.isEditingFromReview;
    session.data['cancelOrigin'] = backup.originalReviewState.cancelOrigin;
    
    // Rebuild global sites array
    session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
    
    // Determine redirect URL based on original method
    let redirectUrl;
    if (backup.originalMethod === 'manual-entry') {
        redirectUrl = 'manual-entry/review-site-details';
    } else {
        redirectUrl = 'review-site-details';
    }
    
    console.log(`✅ METHOD SWITCH: Restored ${backup.originalMethod} method, redirecting to ${redirectUrl}`);
    
    // Clear backup after successful restore
    delete session.data['methodSwitchBackup'];
    
    return redirectUrl;
}

/**
 * Clears method switch backup when user commits to new method
 * @param {Object} session - Express session object
 */
function clearMethodSwitchBackup(session) {
    if (session.data['methodSwitchBackup']) {
        const backup = session.data['methodSwitchBackup'];
        console.log(`🗑️ METHOD SWITCH: Clearing backup for ${backup.originalMethod} (user committed to new method)`);
        delete session.data['methodSwitchBackup'];
    }
}

/**
 * Checks if there's a method switch backup available
 * @param {Object} session - Express session object
 * @returns {Boolean}
 */
function hasMethodSwitchBackup(session) {
    return !!session.data['methodSwitchBackup'];
}

// ==============================================================================================
// METHOD SWITCH EDGE CASE HANDLING
// ==============================================================================================

/**
 * Validates and cleans up stale method switch backups
 * @param {Object} session - Express session object
 */
function validateMethodSwitchBackup(session) {
    const backup = session.data['methodSwitchBackup'];
    if (!backup) return;
    
    // Check if backup is stale (older than 1 hour)
    const oneHour = 60 * 60 * 1000;
    if (Date.now() - backup.timestamp > oneHour) {
        console.log('🗑️ METHOD SWITCH: Clearing stale backup (older than 1 hour)');
        delete session.data['methodSwitchBackup'];
        return;
    }
    
    // Check if backup batch ID conflicts with current batches
    if (session.data['siteBatches']) {
        const conflictingBatch = session.data['siteBatches'].find(batch => batch.id === backup.batch.id);
        if (conflictingBatch) {
            console.log('🗑️ METHOD SWITCH: Clearing backup due to ID conflict');
            delete session.data['methodSwitchBackup'];
        }
    }
}

/**
 * Safe restore function with error recovery
 * @param {Object} session - Express session object
 * @returns {String|null} - Redirect URL or null if restore failed
 */
function safeRestoreMethodSwitchBackup(session) {
    try {
        return restoreMethodSwitchBackup(session);
    } catch (error) {
        console.error('🚨 METHOD SWITCH: Error restoring backup:', error);
        // Clear corrupted backup
        delete session.data['methodSwitchBackup'];
        // Fall back to standard cancel behavior
        return null;
    }
}

/**
 * Cleans up method-specific session variables when switching methods
 * @param {Object} session - Express session object
 * @param {String} methodToKeep - 'manual-entry' or 'file-upload' or 'both' or 'none'
 */
function cleanupMethodSessionData(session, methodToKeep) {
    const manualKeys = [
        'manual-multiple-sites',
        'manual-same-activity-dates', 
        'manual-same-activity-description',
        'manual-start-date-date-input-day',
        'manual-start-date-date-input-month', 
        'manual-start-date-date-input-year',
        'manual-end-date-date-input-day',
        'manual-end-date-date-input-month',
        'manual-end-date-date-input-year',
        'manual-activity-details-text-area'
    ];
    
    const fileKeys = [
        'exemption-which-type-of-file-radios',
        'hasUploadedFile',
        'exemption-same-activity-dates-for-sites',
        'exemption-same-activity-description-for-sites', 
        'exemption-start-date-date-input-day',
        'exemption-start-date-date-input-month',
        'exemption-start-date-date-input-year',
        'exemption-end-date-date-input-day',
        'exemption-end-date-date-input-month', 
        'exemption-end-date-date-input-year',
        'exemption-activity-details-text-area'
    ];
    
    if (methodToKeep !== 'manual-entry' && methodToKeep !== 'both') {
        manualKeys.forEach(key => delete session.data[key]);
    }
    
    if (methodToKeep !== 'file-upload' && methodToKeep !== 'both') {
        fileKeys.forEach(key => delete session.data[key]);
    }
}

// ==============================================================================================
// CANCEL FUNCTIONALITY - STATE DETECTION SYSTEM
// ==============================================================================================

/**
 * Determines the current user state for cancel behavior
 * @param {Object} session - Express session object
 * @returns {String} - 'creation' | 'creation-review' | 'review-not-saved' | 'review-saved'
 */
function determineUserState(session) {
    const reviewVisited = session.data['reviewPageVisited'];
    const reviewSaved = session.data['reviewPageSaved'];
    const isEditing = session.data['isEditingFromReview'];
    
    if (!reviewVisited) {
        console.log('🔍 State Detection: CREATION (review page not visited)');
        return 'creation'; // Pages before review page reached
    }
    
    // NEW LOGIC: If editing from review (change link), ALWAYS return to review regardless of saved status
    if (reviewVisited && isEditing) {
        console.log('🔍 State Detection: CREATION-REVIEW (editing from review via change link)');
        return 'creation-review'; // Back from review for editing - saved status doesn't matter
    }
    
    if (reviewVisited && !reviewSaved) {
        console.log('🔍 State Detection: REVIEW-NOT-SAVED (on review page, first time, not saved)');
        return 'review-not-saved'; // On review page, first time, not saved
    }
    
    if (reviewVisited && reviewSaved) {
        console.log('🔍 State Detection: REVIEW-SAVED (review page previously saved, not editing)');
        return 'review-saved'; // Review page previously saved, not editing
    }
    
    console.log('🔍 State Detection: CREATION (fallback)');
    return 'creation'; // Fallback
}

/**
 * Determines where the user originally came from
 * @param {Object} session - Express session object  
 * @returns {String} - 'task-list' | 'your-sites' | 'check-answers' | 'direct'
 */
function determineOrigin(session) {
    const origin = session.data['cancelOrigin'] || 'task-list';
    console.log('🔍 Origin Detection:', origin);
    return origin;
}

/**
 * Sets the origin context when user enters the flow
 * @param {Object} session - Express session object
 * @param {String} origin - Origin identifier
 */
function setOriginContext(session, origin) {
    console.log('📍 Setting Origin Context:', origin);
    session.data['cancelOrigin'] = origin;
    
    // Clear any conflicting navigation flags when setting new origin
    if (origin === 'task-list') {
        delete session.data['camefromcheckanswers'];
        delete session.data['fromReviewSiteDetails'];
    }
}

/**
 * Tracks review page state changes
 * @param {Object} session - Express session object
 * @param {String} action - 'visited' | 'saved' | 'editing'
 */
function updateReviewState(session, action) {
    console.log('📝 Updating Review State:', action);
    
    switch(action) {
        case 'visited':
            session.data['reviewPageVisited'] = true;
            // Don't change saved or editing state when just visiting
            break;
            
        case 'saved':
            session.data['reviewPageVisited'] = true;
            session.data['reviewPageSaved'] = true;
            session.data['isEditingFromReview'] = false; // Clear editing state after save
            break;
            
        case 'editing':
            // User clicked change link from review page
            session.data['reviewPageVisited'] = true;
            session.data['isEditingFromReview'] = true;
            // Don't change saved state - preserve existing value
            break;
    }
}

/**
 * Comprehensive state logging for debugging
 * @param {Object} session - Express session object
 * @param {String} context - Current page/action context
 */
function logCancelState(session, context) {
    if (process.env.NODE_ENV !== 'production') { // Only log in development
        console.log('🚨 ================== CANCEL STATE DEBUG ==================');
        console.log('📍 Context:', context);
        console.log('🎯 Current State Flags:');
        console.log('   - cancelOrigin:', session.data['cancelOrigin']);
        console.log('   - reviewPageVisited:', session.data['reviewPageVisited']);
        console.log('   - reviewPageSaved:', session.data['reviewPageSaved']);
        console.log('   - isEditingFromReview:', session.data['isEditingFromReview']);
        console.log('   - currentBatchId:', session.data['currentBatchId']);
        
        console.log('🏗️  Legacy Flags (for transition):');
        console.log('   - fromReviewSiteDetails:', session.data['fromReviewSiteDetails']);
        console.log('   - siteDetailsSaved:', session.data['siteDetailsSaved']);
        console.log('   - camefromcheckanswers:', session.data['camefromcheckanswers']);
        console.log('   - returnTo:', session.data['returnTo']);
        
        console.log('📊 Batch Information:');
        const currentBatch = getCurrentBatch(session);
        if (currentBatch) {
            console.log('   - Current Batch ID:', currentBatch.id);
            console.log('   - Entry Method:', currentBatch.entryMethod);
            console.log('   - Site Count:', currentBatch.sites ? currentBatch.sites.length : 0);
        } else {
            console.log('   - No current batch');
        }
        
        console.log('🔍 Determined State:', determineUserState(session));
        console.log('📍 Determined Origin:', determineOrigin(session));
        console.log('🚨 =====================================================');
    }
}

/**
 * Enhanced batch clearing with comprehensive error handling and state management
 * @param {Object} session - Express session object
 */
function clearCurrentBatchSafely(session) {
    const currentBatchId = session.data['currentBatchId'];
    delete session.data['user_type'];
    
    console.log('🗑️ clearCurrentBatchSafely - entry - currentBatchId:', currentBatchId);
    
    if (!currentBatchId) {
        console.log('ℹ️ No current batch to clear - this is normal for direct URL access');
        // Still clear session data in case there's orphaned data
        clearBatchSessionData(session);
        updateTaskStatusAfterClear(session);
        return;
    }
    
    // Validate batch exists before attempting removal
    if (!session.data['siteBatches']) {
        console.log('⚠️ No siteBatches array found - initializing empty array');
        session.data['siteBatches'] = [];
        delete session.data['currentBatchId'];
        clearBatchSessionData(session);
        updateTaskStatusAfterClear(session);
        return;
    }
    
    // Find and remove the current batch
    const batchIndex = session.data['siteBatches'].findIndex(batch => batch.id === currentBatchId);
    if (batchIndex !== -1) {
        const removedBatch = session.data['siteBatches'][batchIndex];
        console.log('🗑️ Removing batch:', removedBatch.id, 'with', removedBatch.sites.length, 'sites');
        
        session.data['siteBatches'].splice(batchIndex, 1);
        
        // Rebuild the global sites array from remaining batches
        const remainingSites = session.data['siteBatches'].flatMap(batch => batch.sites);
        session.data['sites'] = remainingSites;
        
        // Recalculate global site counter
        if (remainingSites.length > 0) {
            const maxGlobalNumber = Math.max(...remainingSites.map(site => site.globalNumber));
            session.data['globalSiteCounter'] = maxGlobalNumber;
            console.log('📊 Updated global site counter to:', maxGlobalNumber);
        } else {
            delete session.data['globalSiteCounter'];
            console.log('📊 No sites remain - cleared global site counter');
        }
    } else {
        console.log('⚠️ Current batch ID not found in siteBatches array - possible data inconsistency');
        // Clear the invalid batch ID
        delete session.data['currentBatchId'];
    }
    
    // Clear current batch related data
    delete session.data['currentBatchId'];
    
    // Clear all session data related to current batch creation
    clearBatchSessionData(session);
    
    // Update task status based on remaining batches
    updateTaskStatusAfterClear(session);
    
    console.log('🗑️ clearCurrentBatchSafely - completed');
}

/**
 * Clear session data related to batch creation and editing
 * @param {Object} session - Express session object
 */
function clearBatchSessionData(session) {
    // Clear entry method session data for both manual and file upload
    clearAllManualEntryData(session);
    // Preserve fileUploadCount when clearing batch data to maintain upload sequence
    const preservedUploadCount = session.data['fileUploadCount'];
    clearAllFileUploadData(session);
    if (preservedUploadCount) {
        session.data['fileUploadCount'] = preservedUploadCount;
    }
    clearAllLocationData(session);
    
    // Clear file upload activity settings
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['previous-activity-dates-selection'];
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['previous-activity-description-selection'];
    delete session.data['exemption-activity-details-text-area'];
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    
    // Clear manual entry activity settings
    delete session.data['manual-same-activity-dates'];
    delete session.data['manual-same-activity-description'];
    delete session.data['manual-activity-details-text-area'];
    delete session.data['manual-start-date-date-input-day'];
    delete session.data['manual-start-date-date-input-month'];
    delete session.data['manual-start-date-date-input-year'];
    delete session.data['manual-end-date-date-input-day'];
    delete session.data['manual-end-date-date-input-month'];
    delete session.data['manual-end-date-date-input-year'];
    
    // Clear coordinate method selection for new batch
    delete session.data['exemption-how-do-you-want-to-provide-the-coordinates-radios'];
    
    // Clear navigation and legacy state flags
    delete session.data['fromReviewSiteDetails'];
    delete session.data['current-site'];
    delete session.data['manual-current-site'];
    delete session.data['returnTo'];
    
    // Clear error states
    delete session.data['errorthispage'];
    delete session.data['errortypeone'];
    delete session.data['errortypetwo'];
    delete session.data['errors'];
    delete session.data['startdateerror'];
    delete session.data['enddateerror'];
    
    console.log('🧹 Cleared batch session data');
}

/**
 * Update task status after clearing batches
 * @param {Object} session - Express session object
 */
function updateTaskStatusAfterClear(session) {
    if (!session.data['siteBatches'] || session.data['siteBatches'].length === 0) {
        // No batches remain - reset to not started
        session.data['exempt-information-3-status'] = 'not-started';
        delete session.data['siteDetailsSaved'];
        delete session.data['sites'];
        delete session.data['siteBatches'];
        delete session.data['hasUploadedFile'];
        console.log('📋 Reset task status to not-started - no batches remain');
    } else {
        // Other batches still exist - determine status from remaining batches
        const hasSavedBatches = session.data['siteBatches'].some(batch => batch.saved);
        if (hasSavedBatches) {
            session.data['exempt-information-3-status'] = 'completed';
            console.log('📋 Maintained completed status - other saved batches exist');
        } else {
            session.data['exempt-information-3-status'] = 'in-progress';
            console.log('📋 Set status to in-progress - unsaved batches exist');
        }
    }
}

// Unified model functions removed - using batch system exclusively

// Update the upload file router to use batch handling
router.post('/' + version + section + 'upload-file-router', function (req, res) {
    req.session.data['siteTitle'] = 'review';
    
    // Check if we already have a file upload batch (user might be changing file within same file type)
    const existingBatch = getCurrentBatch(req.session);
    const hasExistingFileUpload = existingBatch && existingBatch.entryMethod === 'file-upload';
    
    let batchId;
    if (hasExistingFileUpload && req.session.data['fromReviewSiteDetails'] === 'true') {
        // User is changing the uploaded file but keeping same method - clear existing batch first
        clearDataForFileUploadOnly(req.session);
        batchId = initializeBatch(req.session, 'file-upload');
    } else if (!hasExistingFileUpload) {
        // No existing file upload batch - create new one
        batchId = initializeBatch(req.session, 'file-upload');
    } else {
        // Keep existing batch
        batchId = existingBatch.id;
    }
    
    req.session.data['currentBatchId'] = batchId;
    
    // Get current batch and store settings
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch) {
        // Store batch-level settings for file upload (will be populated later)
        currentBatch.settings = {
            sameActivityDates: null, // Will be set in same-activity-dates
            sameActivityDescription: null, // Will be set in same-activity-description
            sharedStartDate: {},
            sharedEndDate: {},
            sharedDescription: null,
            fileType: req.session.data['exemption-which-type-of-file-radios'] // Store file type
        };
    }
    
    // Track upload count to generate different number of sites
    const uploadCount = (req.session.data['fileUploadCount'] || 0) + 1;
    req.session.data['fileUploadCount'] = uploadCount;
    
    // Mark that a file has been uploaded
    req.session.data['hasUploadedFile'] = true;
    
    let sites;
    
    if (uploadCount === 1) {
        // First upload: use 4-site array
        sites = [
            {
                name: 'Sediment sample 1',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-drawn.jpg'
            },
            {
                name: 'Sediment sample 2',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-square.jpg'
            },
            {
                name: 'Sediment sample 3',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-4-points.jpg'
            },
            {
                name: 'Sediment sample 4',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-5-points.jpg'
            }
        ];
    } else if (uploadCount === 2) {
        // Second upload: use 1-site array
        sites = [
            {
                name: 'Sediment sample',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-drawn.jpg'
            }
        ];
    } else {
        // Third and subsequent uploads: use 2-site array
        sites = [
            {
                name: 'Brighton sample',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-drawn.jpg'
            },
            {
                name: 'Worthing sample',
                description: '',
                startDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                endDate: {
                    day: '',
                    month: '',
                    year: ''
                },
                mapImage: '/public/images/map-square.jpg'
            }
        ];
    }
    
    // Add each site to the batch
    sites.forEach(site => addSiteToBatch(req.session, site));
    
    // Determine where to go after checking file based on number of sites
    if (sites.length === 1) {
        // Single site: skip "same for all sites" questions and go directly to site-specific details
        // Use the actual global number of the site, not hardcoded 1
        const currentBatch = getCurrentBatch(req.session);
        const siteGlobalNumber = currentBatch && currentBatch.sites[0] ? currentBatch.sites[0].globalNumber : 1;
        req.session.data['checkingFileRedirect'] = 'site-activity-dates?site=' + siteGlobalNumber;
    } else {
        // Multiple sites: go to same-activity-dates question
        req.session.data['checkingFileRedirect'] = 'same-activity-dates';
    }
    
    // After uploading file, go to checking page first
    res.redirect('checking-file');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Checking file page - clean up redirect data after page is served
/////////////////////////////////////////////////////////////////////////////////////////////

router.get('/' + version + section + 'checking-file', function (req, res) {
    res.render(version + section + 'checking-file');
    
    // Clean up the redirect data after serving the page
    // The meta refresh uses the data at render time, so it's safe to delete immediately
    delete req.session.data['checkingFileRedirect'];
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Are the activity dates the same for every site?
// RADIO BUTTONS
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'same-activity-dates-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const selection = req.session.data['exemption-same-activity-dates-for-sites'];
    const previousSelection = req.session.data['previous-activity-dates-selection'];

    if (!selection) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('same-activity-dates');
        return;
    }

    // Store the current selection for future comparison
    req.session.data['previous-activity-dates-selection'] = selection;
    
    // Save setting to current batch metadata if we have one
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings) {
        currentBatch.settings.sameActivityDates = selection;
    }

    // Check if we're coming from review-site-details page
    const returnTo = req.session.data['returnTo'];
    
    // Route based on selection
    switch(selection) {
        case "Yes":
            // If dates are the same for all sites, take them to the activity-dates page
            // Pass the returnTo parameter so activity-dates knows where to return
            if (returnTo === 'review-site-details') {
                req.session.data['returnTo'] = 'review-site-details';
                res.redirect('activity-dates');
            } else {
                res.redirect('activity-dates');
            }
            break;
        case "No":
            // If coming from review page and changing from Yes to No
            if (returnTo === 'review-site-details' && previousSelection === "Yes") {
                // Copy shared activity dates to each site before clearing shared data
                if (currentBatch && currentBatch.settings && currentBatch.sites) {
                    const sharedStartDate = currentBatch.settings.sharedStartDate;
                    const sharedEndDate = currentBatch.settings.sharedEndDate;
                    
                    // Copy shared dates to each site in the batch
                    currentBatch.sites.forEach(site => {
                        if (sharedStartDate && sharedStartDate.day) {
                            site.startDate = { ...sharedStartDate };
                        }
                        if (sharedEndDate && sharedEndDate.day) {
                            site.endDate = { ...sharedEndDate };
                        }
                    });
                    
                    // Update global sites array to reflect changes
                    req.session.data['sites'] = req.session.data['siteBatches'].flatMap(batch => batch.sites);
                    
                    // Clear from batch settings after copying
                    currentBatch.settings.sharedStartDate = {};
                    currentBatch.settings.sharedEndDate = {};
                }
                
                // Clear shared activity dates from session
                delete req.session.data['exemption-start-date-date-input-day'];
                delete req.session.data['exemption-start-date-date-input-month'];
                delete req.session.data['exemption-start-date-date-input-year'];
                delete req.session.data['exemption-end-date-date-input-day'];
                delete req.session.data['exemption-end-date-date-input-month'];
                delete req.session.data['exemption-end-date-date-input-year'];
                
                // Return to review page
                delete req.session.data['returnTo'];
                res.redirect('review-site-details');
            } else {
                // If dates are different for each site, skip to activity description question
                // We'll collect site-specific dates later
                res.redirect('same-activity-description');
            }
            break;
        default:
            res.redirect('same-activity-dates');
    }
});

router.get('/' + version + section + 'same-activity-dates', function (req, res) {
    const returnTo = req.query.returnTo;
    
    // Check if we're returning from review-site-details
    if (returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    res.render(version + section + 'same-activity-dates', {
        returnTo: returnTo
    });
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Is the activity description the same for every site?
// RADIO BUTTONS
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'same-activity-description-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const selection = req.session.data['exemption-same-activity-description-for-sites'];
    const previousSelection = req.session.data['previous-activity-description-selection'];

    if (!selection) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('same-activity-description');
        return;
    }

    // Store the current selection for future comparison
    req.session.data['previous-activity-description-selection'] = selection;
    
    // Save setting to current batch metadata if we have one
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings) {
        currentBatch.settings.sameActivityDescription = selection;
    }

    // Check if we're coming from review-site-details page
    const returnTo = req.session.data['returnTo'];
    
    // Route based on selection
    switch(selection) {
        case "Yes":
            // If description is the same for all sites, take them to the activity-details page
            if (returnTo === 'review-site-details') {
                req.session.data['returnTo'] = 'review-site-details';
                res.redirect('activity-details');
            } else {
                res.redirect('activity-details');
            }
            break;
        case "No":
            // If coming from review page and changing from Yes to No
            if (returnTo === 'review-site-details' && previousSelection === "Yes") {
                // Copy shared activity description to each site before clearing shared data
                if (currentBatch && currentBatch.settings && currentBatch.sites) {
                    const sharedDescription = currentBatch.settings.sharedDescription;
                    
                    // Copy shared description to each site in the batch
                    if (sharedDescription) {
                        currentBatch.sites.forEach(site => {
                            site.description = sharedDescription;
                        });
                        
                        // Update global sites array to reflect changes
                        req.session.data['sites'] = req.session.data['siteBatches'].flatMap(batch => batch.sites);
                    }
                    
                    // Clear from batch settings after copying
                    currentBatch.settings.sharedDescription = null;
                }
                
                // Clear shared activity description from session
                delete req.session.data['exemption-activity-details-text-area'];
                
                // Return to review page
                delete req.session.data['returnTo'];
                res.redirect('review-site-details');
            } else {
                // If description is different for each site, skip to review-site-details
                // We'll collect site-specific descriptions later
                res.redirect('review-site-details');
            }
            break;
        default:
            res.redirect('same-activity-description');
    }
});

router.get('/' + version + section + 'same-activity-description', function (req, res) {
    const returnTo = req.query.returnTo;
    
    // Check if we're returning from review-site-details
    if (returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    res.render(version + section + 'same-activity-description', {
        returnTo: returnTo
    });
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Site-specific name
// TEXT ENTRY
/////////////////////////////////////////////////////////////////////////////////////////////

// GET handler for site-name
router.get('/' + version + section + 'site-name', function (req, res) {
    // Check if we're returning from review-site-details
    if (req.query.return && req.query.return.includes('site-')) {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    // Store the return parameter for redirecting back later
    if (req.query.return) {
        req.session.data['return'] = req.query.return;
    }
    
    // If we have a site query parameter, set the active site
    if (req.query.site) {
        req.session.data['site'] = req.query.site;
    }
    
    res.render(version + section + 'site-name');
});

router.post('/' + version + section + 'site-name-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    const siteName = req.session.data['site-name-text-input'];
    const globalSiteNumber = parseInt(req.session.data['site']) || 1;
    const returnSection = req.session.data['return'];

    if (!siteName || siteName.trim() === "") {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        return res.redirect('site-name');
    }

    // If we have a return section and existing sites, we're updating an existing site
    if (returnSection && req.session.data['sites'] && req.session.data['sites'].length >= 1) {
        // Find the site by global number and update it
        const siteToUpdate = findSiteByGlobalNumber(req.session, globalSiteNumber);
        
        if (siteToUpdate) {
            siteToUpdate.name = siteName;
            
            // Update the site in its batch as well
            if (siteToUpdate.batchId) {
                const batch = req.session.data['siteBatches']?.find(b => b.id === siteToUpdate.batchId);
                if (batch) {
                    const batchSite = batch.sites.find(s => s.globalNumber === globalSiteNumber);
                    if (batchSite) {
                        batchSite.name = siteName;
                    }
                }
            }
            
            // Rebuild global sites array
            req.session.data['sites'] = req.session.data['siteBatches'].flatMap(batch => batch.sites);
        }
        
        // Clear the input field
        req.session.data['site-name-text-input'] = '';
        

        
        // Redirect back to review-site-details with the anchor
        return res.redirect('review-site-details#' + returnSection);
    }

    // If we're not updating an existing site, create a new one (manual entry flow)
    // Get current batch
    const batch = getCurrentBatch(req.session);
    if (!batch) {
        // Initialize a new batch for manual entry if none exists
        initializeBatch(req.session, 'manual-entry');
    }

    // Create new site data
    const siteData = {
        name: siteName,
        startDate: {},
        endDate: {},
        description: ''
    };

    // Add site to current batch
    addSiteToBatch(req.session, siteData);
    
    // If we need site-specific dates and we're not returning to somewhere else
    if (req.session.data['exemption-same-activity-dates-for-sites'] === "No" && !returnSection) {
        // Go to site-specific dates page
        return res.redirect('site-activity-dates?site=' + siteData.globalNumber);
    } 
    // If we need site-specific descriptions and we're not returning to somewhere else
    else if (req.session.data['exemption-same-activity-description-for-sites'] === "No" && !returnSection) {
        // Go to site-specific description page
        return res.redirect('site-activity-description?site=' + siteData.globalNumber);
    }
    else if (returnSection) {
        // Redirect back to review-site-details with the anchor
        return res.redirect('review-site-details#' + returnSection);
    }
    else {
        // Default: return to task list
        return res.redirect('task-list');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Site-specific activity dates
// DATE ENTRY - both start and end
//////////////////////////////////////////////////////////////////////////////////////////////

// GET handler for site-activity-dates
router.get('/' + version + section + 'site-activity-dates', function (req, res) {
    // Check if we're returning from review-site-details
    if (req.query.return && req.query.return.includes('site-')) {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    // If we have a site query parameter, set the active site
    if (req.query.site) {
        req.session.data['site'] = req.query.site;
    }

    // Get current batch and sites for template data
    const currentBatch = getCurrentBatch(req.session);
    let sites = [];
    if (currentBatch) {
        sites = currentBatch.sites;
    }

    // Find the specific site being edited
    const siteParam = req.query.site || req.session.data['site'];
    const site = sites.find(s => s.globalNumber === parseInt(siteParam));
    
    res.render(version + section + 'site-activity-dates', {
        data: req.session.data,
        sites: sites,
        currentBatch: currentBatch,
        site: site
    });
});

// POST handler for site-activity-dates
router.post('/' + version + section + 'site-activity-dates-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errortypetwo'] = "false";
    req.session.data['startdateerror'] = "false";
    req.session.data['enddateerror'] = "false";

    const siteIndex = parseInt(req.session.data['site']) || 1;
    
    // Validate input data - start date
    const sitePrefix = 'site-' + siteIndex + '-';
    const startDay = req.session.data[sitePrefix + 'start-date-day'];
    const startMonth = req.session.data[sitePrefix + 'start-date-month'];
    const startYear = req.session.data[sitePrefix + 'start-date-year'];
    
    // Validate input data - end date
    const endDay = req.session.data[sitePrefix + 'end-date-day'];
    const endMonth = req.session.data[sitePrefix + 'end-date-month'];
    const endYear = req.session.data[sitePrefix + 'end-date-year'];

    // Check if any fields are missing
    if (!startDay || !startMonth || !startYear || !endDay || !endMonth || !endYear) {
        req.session.data['errorthispage'] = "true";
        
        // Set which specific fields have errors
        if (!startDay || !startMonth || !startYear) {
            req.session.data['errortypeone'] = "true";
            req.session.data['startdateerror'] = "true";
        }
        
        if (!endDay || !endMonth || !endYear) {
            req.session.data['errortypetwo'] = "true";
            req.session.data['enddateerror'] = "true";
        }
        
        return res.redirect('site-activity-dates?site=' + siteIndex);
    }

    // Update the site in the sites array
    const sites = req.session.data['sites'] || [];
    if (sites.length >= siteIndex) {
        // Create the date objects if they don't exist
        if (!sites[siteIndex-1].startDate) {
            sites[siteIndex-1].startDate = {};
        }
        
        if (!sites[siteIndex-1].endDate) {
            sites[siteIndex-1].endDate = {};
        }
        
        // Update the dates
        sites[siteIndex-1].startDate = {
            day: startDay,
            month: startMonth,
            year: startYear
        };
        
        sites[siteIndex-1].endDate = {
            day: endDay,
            month: endMonth,
            year: endYear
        };
        
        // Save the updated array back to the session
        req.session.data['sites'] = sites;
        
        // Also update the site in the current batch
        const currentBatch = getCurrentBatch(req.session);
        if (currentBatch && currentBatch.sites) {
            const batchSite = currentBatch.sites.find(site => site.globalNumber === siteIndex);
            if (batchSite) {
                batchSite.startDate = {
                    day: startDay,
                    month: startMonth,
                    year: startYear
                };
                batchSite.endDate = {
                    day: endDay,
                    month: endMonth,
                    year: endYear
                };
            }
        }
    }
    
    // Extract the return parameter which contains the section name
    const returnSection = req.session.data['return'];
    
    if (returnSection) {
        // Redirect back to review-site-details with the anchor
        return res.redirect('review-site-details#' + returnSection);
    }
    
    // Check if this is a single site batch from file upload
    const currentBatch = getCurrentBatch(req.session);
    const isSingleSiteBatch = currentBatch && currentBatch.sites && currentBatch.sites.length === 1;
    
    // For single site batches, check if this site belongs to the current batch
    let isSiteInCurrentBatch = false;
    if (isSingleSiteBatch && currentBatch.sites[0]) {
        isSiteInCurrentBatch = currentBatch.sites[0].globalNumber === siteIndex;
    }
    
    if (isSingleSiteBatch && isSiteInCurrentBatch) {
        // Single site: go to activity description next
        res.redirect('site-activity-description?site=' + siteIndex);
    } else {
        // Multiple sites: return to review-site-details without anchor
        res.redirect('review-site-details');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Site-specific activity description
// TEXT ENTRY (TEXTAREA)
/////////////////////////////////////////////////////////////////////////////////////////////

// GET handler for site-activity-description
router.get('/' + version + section + 'site-activity-description', function (req, res) {
    // Check if we're returning from review-site-details
    if (req.query.return && req.query.return.includes('site-')) {
        req.session.data['fromReviewSiteDetails'] = 'true';
        updateReviewState(req.session, 'editing');
    }
    
    // If we have a site query parameter, set the active site
    if (req.query.site) {
        req.session.data['site'] = req.query.site;
    }

    // Get current batch and sites for template data
    const currentBatch = getCurrentBatch(req.session);
    let sites = [];
    if (currentBatch) {
        sites = currentBatch.sites;
    }

    // Find the specific site being edited
    const siteParam = req.query.site || req.session.data['site'];
    const site = sites.find(s => s.globalNumber === parseInt(siteParam));
    
    res.render(version + section + 'site-activity-description', {
        data: req.session.data,
        sites: sites,
        currentBatch: currentBatch,
        site: site
    });
});

// POST handler for site-activity-description
router.post('/' + version + section + 'site-activity-description-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    
    const siteIndex = parseInt(req.session.data['site']) || 1;
    const description = req.session.data['site-' + siteIndex + '-activity-description'];
    
    if (!description || description.trim() === "") {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        return res.redirect('site-activity-description?site=' + siteIndex);
    }
    
    // Update the site in the sites array
    const sites = req.session.data['sites'] || [];
    if (sites.length >= siteIndex) {
        // Update the description - save to description property to match what the review template checks
        sites[siteIndex-1].description = description;
        
        // Save the updated array back to the session
        req.session.data['sites'] = sites;
        
        // Also update the site in the current batch
        const currentBatch = getCurrentBatch(req.session);
        if (currentBatch && currentBatch.sites) {
            const batchSite = currentBatch.sites.find(site => site.globalNumber === siteIndex);
            if (batchSite) {
                batchSite.description = description;
            }
        }
    }
    
    // Extract the return parameter which contains the section name
    const returnSection = req.session.data['return'];
    
    if (returnSection) {
        // Redirect back to review-site-details with the anchor
        return res.redirect('review-site-details#' + returnSection);
    }
    
    // Default: return to review-site-details without anchor
    res.redirect('review-site-details');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Review Site Details
// REVIEW PAGE
/////////////////////////////////////////////////////////////////////////////////////////////

router.post('/' + version + section + 'review-site-details-router', function (req, res) {
    // Clear any method switch backup - user is committing to file upload method
    clearMethodSwitchBackup(req.session);
    
    let hasSiteIncomplete = false;
    let sites = [];
    if (typeof getCurrentBatch === 'function') {
        const batch = getCurrentBatch(req.session);
        if (batch) {
            sites = batch.sites;
        }
    }
    if (sites.length > 0) {
        for (const site of sites) {
            if (!site.name) {
                hasSiteIncomplete = true;
            }
            
            if (sites.length === 1) {
                // Single site: always require dates and description
                if (!site.startDate || !site.startDate.day) {
                    hasSiteIncomplete = true;
                }
                if (!site.description) {
                    hasSiteIncomplete = true;
                }
            } else {
                // Multiple sites: check conditionally based on "same for all sites" settings
                if (req.session.data['exemption-same-activity-dates-for-sites'] === "No") {
                    if (!site.startDate || !site.startDate.day) {
                        hasSiteIncomplete = true;
                    }
                }
                if (req.session.data['exemption-same-activity-description-for-sites'] === "No") {
                    if (!site.description) {
                        hasSiteIncomplete = true;
                    }
                }
            }
        }
        if (hasSiteIncomplete) {
            req.session.data['exempt-information-3-status'] = 'in-progress';
        } else {
            req.session.data['exempt-information-3-status'] = 'completed';
        }
    } else {
        req.session.data['exempt-information-3-status'] = 'cannot-start';
    }
    req.session.data['siteDetailsSaved'] = true;
    delete req.session.data['fromReviewSiteDetails'];
    
    // Track that review page has been saved
    updateReviewState(req.session, 'saved');
    logCancelState(req.session, 'review-site-details POST - sites saved');
    
    // Store batch info for task list navigation
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch) {
        req.session.data['lastBatchType'] = currentBatch.entryMethod;
        req.session.data['lastBatchId'] = currentBatch.id;
    }
    
    // Clear currentBatchId so we can start fresh next time
    delete req.session.data['currentBatchId'];
    
    // Note: Keep inSiteDetailsJourney flag - user still in site details section until they go to task list
    
    if (req.session.data['camefromcheckanswers'] === 'true') {
        req.session.data['camefromcheckanswers'] = false;
        // Clear journey flag when leaving site details section
        delete req.session.data['inSiteDetailsJourney'];
        res.redirect('check-answers-multiple-sites');
    } else {
        // Clear journey flag when leaving site details section  
        delete req.session.data['inSiteDetailsJourney'];
        res.redirect('task-list');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Site details added - REMOVED
// This section has been removed as part of "Remove Your Sites Page" task
/////////////////////////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////////////////////////
// Cancel actions - NEW STATE-BASED SYSTEM
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Main cancel route handler - uses new state detection system
 * Replaces cancel-site-details, cancel-to-review, and cancel-from-review-site-details
 */
router.get('/' + version + section + 'cancel-site-details', function (req, res) {
    // Validate method switch backup for edge cases
    validateMethodSwitchBackup(req.session);
    
    const userState = determineUserState(req.session);
    const origin = determineOrigin(req.session);
    
    logCancelState(req.session, 'cancel-site-details entry - userState: ' + userState + ', origin: ' + origin);
    
    // NEW: Check for method switch backup first
    if (hasMethodSwitchBackup(req.session)) {
        console.log('🔄 METHOD SWITCH: Backup detected during cancel, attempting restore');
        const redirectUrl = safeRestoreMethodSwitchBackup(req.session);
        if (redirectUrl) {
            console.log(`🔄 METHOD SWITCH: Redirecting to restored method at ${redirectUrl}`);
            return res.redirect(redirectUrl);
        }
    }
    
    // EXISTING: Original cancel logic unchanged
    switch(userState) {
        case 'creation':
            // State 1: Creation pages - clear current batch and return to task list
            logCancelState(req.session, 'CREATION STATE: Clearing current batch and returning to task list');
            clearCurrentBatchSafely(req.session);
            // Clear state tracking variables for fresh start
            req.session.data['reviewPageVisited'] = false;
            req.session.data['reviewPageSaved'] = false;
            req.session.data['isEditingFromReview'] = false;
            res.redirect('task-list');
            break;
            
        case 'creation-review':
            // State 2: Creation review pages - return to review page
            logCancelState(req.session, 'CREATION-REVIEW STATE: Checking if canceling new site creation');
            
            // Check if we're canceling creation of a new subsequent site
            const creatingNewSiteNumber = req.session.data['creatingNewSiteNumber'];
            
            if (creatingNewSiteNumber) {
                // User is canceling creation of a new subsequent site
                console.log(`🗑️ CANCEL: Removing incomplete site ${creatingNewSiteNumber}`);
                
                const currentBatch = getCurrentBatch(req.session);
                if (currentBatch) {
                    // Find and remove the incomplete site
                    const siteIndex = currentBatch.sites.findIndex(
                        s => s.globalNumber === parseInt(creatingNewSiteNumber)
                    );
                    
                    if (siteIndex !== -1) {
                        console.log(`🗑️ Found incomplete site at index ${siteIndex}, removing...`);
                        currentBatch.sites.splice(siteIndex, 1);
                        
                        // Decrement global site counter
                        if (req.session.data['globalSiteCounter']) {
                            req.session.data['globalSiteCounter']--;
                        }
                        
                        // Rebuild global sites array
                        if (req.session.data['siteBatches']) {
                            req.session.data['sites'] = req.session.data['siteBatches']
                                .flatMap(batch => batch.sites);
                        }
                        
                        console.log(`✅ Removed site ${creatingNewSiteNumber}, counter now: ${req.session.data['globalSiteCounter']}`);
                    } else {
                        console.log(`⚠️ Site ${creatingNewSiteNumber} not found in batch (may not have been added yet)`);
                    }
                }
                
                // Clear the flag
                delete req.session.data['creatingNewSiteNumber'];
            }
            
            // Clear editing flag to indicate user is back on review page
            req.session.data['isEditingFromReview'] = false;
            
            // Determine which review page to return to based on current batch type
            const currentBatch = getCurrentBatch(req.session);
            if (currentBatch && currentBatch.entryMethod === 'manual-entry') {
                res.redirect('manual-entry/review-site-details');
            } else {
                res.redirect('review-site-details');
            }
            break;
            
        case 'review-not-saved':
            // REMOVED: Warning page no longer needed
            // This case occurred when user used back button after reaching review page
            // Now we treat this the same as 'creation' - clear and return to task list
            logCancelState(req.session, 'REVIEW-NOT-SAVED STATE: Treating as creation, clearing batch and returning to task list');
            clearCurrentBatchSafely(req.session);
            req.session.data['reviewPageVisited'] = false;
            req.session.data['reviewPageSaved'] = false;
            req.session.data['isEditingFromReview'] = false;
            res.redirect('task-list');
            break;
            
        case 'review-saved':
            // State 4: Review page saved - route based on origin (no warning needed since data is already saved)
            logCancelState(req.session, 'REVIEW-SAVED STATE: Routing based on origin: ' + origin);
            
            if (origin === 'check-answers') {
                // Return to Check Answers page
                // Clear the navigation flag
                req.session.data['camefromcheckanswers'] = false;
                res.redirect('check-answers-multiple-sites');
            } else {
                // For task-list origin, return to task list (no warning needed - data already saved)
                res.redirect('task-list');
            }
            break;
            
        default:
            // Error handling - fallback to warning page
            logCancelState(req.session, 'ERROR: Unknown user state, falling back to warning page');
            console.error('Unknown user state in cancel-site-details:', userState);
            res.redirect('cancel');
            break;
    }
});

/**
 * Legacy cancel routes - redirect to main handler for backward compatibility
 * These will be updated in Task 4 when templates are updated
 */
router.get('/' + version + section + 'cancel-to-review', function (req, res) {
    logCancelState(req.session, 'cancel-to-review - redirecting to main handler');
    res.redirect('cancel-site-details');
});

router.get('/' + version + section + 'cancel-from-review-site-details', function (req, res) {
    logCancelState(req.session, 'cancel-from-review-site-details - redirecting to main handler');
    res.redirect('cancel-site-details');
});

// GET route for cancel warning page
router.get('/' + version + section + 'cancel', function (req, res) {
    res.render(version + section + 'cancel');
});

// POST route for cancel confirmation - enhanced with state management
router.post('/' + version + section + 'cancel-confirmed', function (req, res) {
    logCancelState(req.session, 'cancel-confirmed - user confirmed cancellation');
    delete req.session.data['user_type'];
    
    // Clear any method switch backup (user explicitly confirmed cancellation)
    clearMethodSwitchBackup(req.session);
    
    // ENHANCED FIX: Force complete clear when user explicitly confirms cancellation
    // This handles the edge case where restored backups might have saved batches
    // that would otherwise keep the task status as "in-progress"
    clearAllSiteDetails(req.session);
    
    // Clear cancel-related state tracking for fresh start
    delete req.session.data['cancelOrigin'];
    delete req.session.data['inSiteDetailsJourney'];
    req.session.data['reviewPageVisited'] = false;
    req.session.data['reviewPageSaved'] = false;
    req.session.data['isEditingFromReview'] = false;
    
    // Clear any legacy navigation flags
    delete req.session.data['fromReviewSiteDetails'];
    delete req.session.data['camefromcheckanswers'];
    
    // Ensure task status is properly reset to not-started
    req.session.data['exempt-information-3-status'] = 'not-started';
    delete req.session.data['siteDetailsSaved'];
    
    logCancelState(req.session, 'cancel-confirmed - complete clear performed, redirecting to task-list');
    res.redirect('task-list');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Delete all sites functionality (from manual entry review page)
/////////////////////////////////////////////////////////////////////////////////////////////

// GET route for delete all sites warning page
router.get('/' + version + section + 'delete-all-sites', function (req, res) {
    res.render(version + section + 'delete-all-sites');
});

// POST route for delete all sites confirmation
router.post('/' + version + section + 'delete-all-sites-confirmed', function (req, res) {
    logCancelState(req.session, 'delete-all-sites-confirmed - user confirmed deletion of all sites');
    
    // Clear any method switch backup (user explicitly confirmed deletion)
    clearMethodSwitchBackup(req.session);
    
    // Force complete clear of all site details
    clearAllSiteDetails(req.session);
    
    // Clear state tracking for fresh start
    delete req.session.data['cancelOrigin'];
    delete req.session.data['inSiteDetailsJourney'];
    req.session.data['reviewPageVisited'] = false;
    req.session.data['reviewPageSaved'] = false;
    req.session.data['isEditingFromReview'] = false;
    
    // Clear any legacy navigation flags
    delete req.session.data['fromReviewSiteDetails'];
    delete req.session.data['camefromcheckanswers'];
    
    // Ensure task status is properly reset to not-started
    req.session.data['exempt-information-3-status'] = 'not-started';
    delete req.session.data['siteDetailsSaved'];
    
    logCancelState(req.session, 'delete-all-sites-confirmed - complete clear performed, redirecting to task-list');
    res.redirect('task-list');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// More than one site change functionality (from single-site review page)
/////////////////////////////////////////////////////////////////////////////////////////////

// GET route for changing number of sites from single-site review
router.get('/' + version + section + 'more-than-one-site', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    
    // Pass returnTo parameter to template if provided
    if (req.query.returnTo) {
        req.session.data['returnTo'] = req.query.returnTo;
    }
    
    // If coming from single-site review, pre-select "No" to reflect their previous choice
    if (req.query.returnTo === 'review-site-details') {
        req.session.data['exemption-multiple-sites-radios'] = 'No';
    }
    
    res.render(version + section + 'multiple-sites-question');
});

// POST route for handling number of sites change
router.post('/' + version + section + 'more-than-one-site-router', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    
    const selection = req.session.data['exemption-multiple-sites-radios'];
    
    // Validate selection
    if (!selection) {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        return res.redirect('more-than-one-site' + (req.query.returnTo ? '?returnTo=' + req.query.returnTo : ''));
    }
    
    // If coming from single-site review and user selects "Yes" (multiple sites)
    if (req.query.returnTo === 'review-site-details' && selection === 'Yes') {
        // CONVERSION: Single site to multiple sites
        // This is the ONLY place where we create batches for single sites
        
        // Create site data object from single-site session data
        // IMPORTANT: Structure data to match what multiple sites review template expects
        const siteData = {
            // Activity dates at site level (not nested in activityDates)
            startDate: {
                day: req.session.data['single-site-start-date-date-input-day'],
                month: req.session.data['single-site-start-date-date-input-month'],
                year: req.session.data['single-site-start-date-date-input-year']
            },
            endDate: {
                day: req.session.data['single-site-end-date-date-input-day'],
                month: req.session.data['single-site-end-date-date-input-month'],
                year: req.session.data['single-site-end-date-date-input-year']
            },
            description: req.session.data['single-site-activity-details-text-area'],
            
            // Coordinate system at site level (not nested in coordinates)
            coordinateSystem: req.session.data['single-site-coordinate-system-radios'],
            
            // Coordinates object with type property (not entryMethod)
            coordinates: {},
            
            name: undefined  // Single sites don't have names - this makes Site 1 incomplete
        };
        
        // Add coordinate data based on entry method - structure for multiple sites template
        if (req.session.data['single-site-coordinate-entry-method'] === "Enter one set of coordinates and a width to create a circular site") {
            siteData.coordinates.type = 'circle';
            siteData.coordinates.center = {  // Note: 'center' not 'centrePoint'
                latitude: req.session.data['single-site-latitude'],
                longitude: req.session.data['single-site-longitude']
            };
            siteData.coordinates.width = req.session.data['single-site-width'];
        } else if (req.session.data['single-site-coordinate-entry-method'] === "Enter multiple sets of coordinates to mark the boundary of the site") {
            siteData.coordinates.type = 'polygon';
            siteData.coordinates.points = [];
            for (let i = 1; i <= 5; i++) {
                const lat = req.session.data[`single-site-coordinates-point-${i}-latitude`];
                const long = req.session.data[`single-site-coordinates-point-${i}-longitude`];
                if (lat && long) {
                    siteData.coordinates.points.push({
                        pointNumber: i,
                        latitude: lat,
                        longitude: long
                    });
                }
            }
        }
        
        // NOW create the batch and add the site (first time using batch system)
        // Use 'manual-entry' so it routes to the correct multiple sites review page
        if (!getCurrentBatch(req.session)) {
            initializeBatch(req.session, 'manual-entry');
        }
        
        addSiteToBatch(req.session, siteData);
        
        // Set batch entryMethod to 'manual-entry' for unified processing
        const createdBatch = getCurrentBatch(req.session);
        if (createdBatch) {
            createdBatch.entryMethod = 'manual-entry';
        }
        
        // Set conversion flag and clear single-site mode
        req.session.data['converted-from-single-site'] = 'true';
        delete req.session.data['single-site-completed'];
        
        // Mark as in-progress (Site 1 needs a name)
        req.session.data['exempt-information-3-status'] = 'in-progress';
        
        // Clear single-site session data since we've moved to batch system
        const keysToDelete = Object.keys(req.session.data).filter(key => key.startsWith('single-site-'));
        keysToDelete.forEach(key => {
            delete req.session.data[key];
        });
        
        // Clear the returnTo parameter
        delete req.session.data['returnTo'];
        
        // Redirect to task list
        return res.redirect('task-list');
    }
    
    // For other cases, follow the normal flow
    if (selection === 'Yes') {
        res.redirect('manual-entry/does-your-project-involve-more-than-one-site');
    } else {
        res.redirect('manual-entry/does-your-project-involve-more-than-one-site');
    }
});

// Function to clear data when changing file type (but keeping coordinate method)
function clearDataForFileTypeChange(session) {
    // Clear file type and upload data only
    delete session.data['exemption-which-type-of-file-radios'];
    delete session.data['hasUploadedFile'];
    // Reset upload count for review page changes to get consistent site generation
    delete session.data['fileUploadCount'];
    
    // Clear the current batch and all associated sites
    const currentBatchId = session.data['currentBatchId'];
    if (currentBatchId && session.data['siteBatches']) {
        session.data['siteBatches'] = session.data['siteBatches'].filter(batch => batch.id !== currentBatchId);
        
        if (session.data['siteBatches'].length === 0) {
            delete session.data['globalSiteCounter'];
        } else {
            let maxGlobalNumber = 0;
            session.data['siteBatches'].forEach(batch => {
                batch.sites.forEach(site => {
                    if (site.globalNumber > maxGlobalNumber) {
                        maxGlobalNumber = site.globalNumber;
                    }
                });
            });
            session.data['globalSiteCounter'] = maxGlobalNumber;
        }
    }
    
    delete session.data['currentBatchId'];
    
    // Clear activity dates and descriptions
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    delete session.data['exemption-activity-details-text-area'];
}

// Function to clear data when changing uploaded file only (keeping coordinate method and file type)
function clearDataForFileUploadOnly(session) {
    // Clear upload flag and reset count for review page changes
    delete session.data['hasUploadedFile'];
    // Reset upload count for review page changes to get consistent site generation
    delete session.data['fileUploadCount'];
    
    // Clear the current batch and all associated sites
    const currentBatchId = session.data['currentBatchId'];
    if (currentBatchId && session.data['siteBatches']) {
        session.data['siteBatches'] = session.data['siteBatches'].filter(batch => batch.id !== currentBatchId);
        
        if (session.data['siteBatches'].length === 0) {
            delete session.data['globalSiteCounter'];
        } else {
            let maxGlobalNumber = 0;
            session.data['siteBatches'].forEach(batch => {
                batch.sites.forEach(site => {
                    if (site.globalNumber > maxGlobalNumber) {
                        maxGlobalNumber = site.globalNumber;
                    }
                });
            });
            session.data['globalSiteCounter'] = maxGlobalNumber;
        }
    }
    
    delete session.data['currentBatchId'];
    
    // Clear activity dates and descriptions
    delete session.data['exemption-same-activity-dates-for-sites'];
    delete session.data['exemption-same-activity-description-for-sites'];
    delete session.data['exemption-start-date-date-input-day'];
    delete session.data['exemption-start-date-date-input-month'];
    delete session.data['exemption-start-date-date-input-year'];
    delete session.data['exemption-end-date-date-input-day'];
    delete session.data['exemption-end-date-date-input-month'];
    delete session.data['exemption-end-date-date-input-year'];
    delete session.data['exemption-activity-details-text-area'];
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Help pages
/////////////////////////////////////////////////////////////////////////////////////////////

// GET route for cookies page
router.get('/' + version + 'help/cookies', function (req, res) {
    // Clear error states
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    
    // Set default analytics cookies selection if not already set
    // Use explicit check for undefined to ensure 'no' is always set as default
    if (req.session.data['analytics-cookies'] === undefined || req.session.data['analytics-cookies'] === null) {
        req.session.data['analytics-cookies'] = 'no';
    }
    
    // Render the page
    res.render(version + 'help/cookies');
    
    // Clear the banner flag after rendering so it doesn't show on refresh
    if (req.session.data['cookieSettingsSaved'] === 'true') {
        delete req.session.data['cookieSettingsSaved'];
    }
});

// POST route for cookies page - handle form submission
router.post('/' + version + 'help/cookies', function (req, res) {
    // Get the selection from the form
    const selection = req.body['analytics-cookies'];
    
    // Save the selection
    req.session.data['analytics-cookies'] = selection;
    
    // Set flag to show the success banner
    req.session.data['cookieSettingsSaved'] = 'true';
    
    // Redirect back to the same page to show the banner
    res.redirect('/' + version + 'help/cookies');
});

// Unified model global exports removed - using batch system exclusively

router.get('/' + version + section + 'organisation-selector', function (req, res) {
    // If the user is changing their organisation, set a flag in the session
    const isChangingOrg = req.query.change === 'true';
    if (isChangingOrg) {
        req.session.data['changing-organisation'] = 'true';
    }

    const allOrganisations = [
        {value: "Brighton Marina Operations", text: "Brighton Marina Operations"},
        {value: "Grimsby Fish Dock Enterprise", text: "Grimsby Fish Dock Enterprise"},
        {value: "North East Wind Farms", text: "North East Wind Farms"},
        {value: "Ramsgate Marina", text: "Ramsgate Marina"}
    ];

    const currentOrganisation = req.session.data['organisation-name'];
    const organisations = allOrganisations.filter(org => org.value !== currentOrganisation);

    res.render(version + section + 'organisation-selector', {
        organisations: organisations,
        changingOrganisation: isChangingOrg
    });
});

// organisation selector autocomplete route
router.get('/' + version + section + 'organisation-selector-autocomplete', function (req, res) {
    // If the user is changing their organisation, set a flag in the session
    const isChangingOrg = req.query.change === 'true';
    if (isChangingOrg) {
        req.session.data['changing-organisation'] = 'true';
    }

    res.render(version + section + 'organisation-selector-autocomplete', {
        changingOrganisation: isChangingOrg
    });
});

// organisation selector autocomplete router
router.post('/' + version + section + 'organisation-selector-autocomplete-router', function (req, res) {
    // Turn off errors by default
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";

    // Check if the autocomplete value is selected
    if (!req.session.data['organisation-name'] || req.session.data['organisation-name'].trim() === '') {
        req.session.data['errorthispage'] = "true";
        req.session.data['errortypeone'] = "true";
        res.redirect('organisation-selector-autocomplete');
    } else {
        // If the user is changing their organisation, redirect to the home page
        if (req.session.data['changing-organisation'] === 'true') {
            // Toggle the alternative project view
            req.session.data['alternativeProjectView'] = req.session.data['alternativeProjectView'] === 'true' ? 'false' : 'true';
            // Reset the flag
            delete req.session.data['changing-organisation'];
            res.redirect('home');
        } else {
            // Check if user came from sign-out (goto=home parameter)
            if (req.session.data['goto'] === 'home') {
                // Clear the goto parameter and redirect to home
                delete req.session.data['goto'];
                res.redirect('home');
            } else {
                // Redirect to the project name page for new users
                res.redirect('project-name-start');
            }
        }
    }
});

// Change organisation warning page route
router.get('/' + version + section + 'change-organisation-warning', function (req, res) {
    res.render(version + section + 'change-organisation-warning');
});

// Change organisation confirmation route
router.post('/' + version + section + 'change-organisation-confirmed', function (req, res) {
    // Check if review page has been saved to determine clearing strategy
    const reviewPageSaved = req.session.data['reviewPageSaved'];
    
    if (reviewPageSaved) {
        // Review page was saved - preserve saved data, only clear current journey
        console.log('🔄 CHANGE ORG: Review page was saved, preserving data');
        clearCurrentBatchSafely(req.session);
    } else {
        // Review page not saved - complete clear like cancel functionality
        console.log('🔄 CHANGE ORG: Review page not saved, performing complete clear');
        clearMethodSwitchBackup(req.session);
        clearAllSiteDetails(req.session);
        
        // Reset task status to not-started
        req.session.data['exempt-information-3-status'] = 'not-started';
        delete req.session.data['siteDetailsSaved'];
    }
    
    // Clear site details journey flag and other state tracking variables
    delete req.session.data['inSiteDetailsJourney'];
    delete req.session.data['reviewPageVisited'];
    delete req.session.data['reviewPageSaved'];
    delete req.session.data['isEditingFromReview'];
    
    // Clear any legacy navigation flags
    delete req.session.data['fromReviewSiteDetails'];
    delete req.session.data['camefromcheckanswers'];
    
    // Set changing organisation flag
    req.session.data['changing-organisation'] = 'true';
    
    // Redirect to appropriate organisation selector based on component type
    if (req.session.data['component_type'] === 'autocomplete') {
        res.redirect('organisation-selector-autocomplete');
    } else {
        res.redirect('organisation-selector');
    }
});

};