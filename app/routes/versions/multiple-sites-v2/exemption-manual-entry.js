// Generated by Copilot

const path = require('path');

// LEGACY CODE REMOVED: renumberManualEntrySessionData function
// This was replaced by the unified model's renumberUnifiedSitesAfterDeletion function

// Import unified model functions from exemption.js
const exemptionModule = require('./exemption.js');

// TEMPORARY: Backward compatibility function
function ensureUnifiedModelCompatibility(session) {
    // If using old session-based approach, migrate to unified model
    if (!session.data['unifiedSites'] && session.data['manual-site-name-text-input']) {
        console.log('Migrating legacy session data to unified model');
        migrateToUnifiedModel(session);
        
        // Create site from legacy session data
        const site = createNewSite(session);
        site.name = session.data['manual-site-name-text-input'] || '';
        
        // Clear legacy session keys
        Object.keys(session.data).forEach(key => {
            if (key.startsWith('manual-site-')) {
                delete session.data[key];
            }
        });
        
        session.data['currentManualEntrySiteId'] = site.id;
    }
}

module.exports = function (router) {
    let version = "versions/multiple-sites-v2/";
    let section = "exemption/";

//////////////////////////////////////////////////////////////////////////////////////////////
// Manual Entry Flow Routes
//////////////////////////////////////////////////////////////////////////////////////////////
// Batch handling functions
function initializeBatch(session, entryMethod) {
    const batchId = Date.now().toString(); // Unique batch ID
    const batch = {
        id: batchId,
        entryMethod: entryMethod,
        createdAt: new Date().toISOString(),
        sites: [],
        startingGlobalNumber: session.data['globalSiteCounter'] || 0  // Store the starting position
    };
    if (!session.data['siteBatches']) {
        session.data['siteBatches'] = [];
    }
    session.data['siteBatches'].push(batch);
    session.data['currentBatchId'] = batchId;
    return batchId;
}

function getCurrentBatch(session) {
    const batchId = session.data['currentBatchId'];
    if (!batchId || !session.data['siteBatches']) {
        return null;
    }
    return session.data['siteBatches'].find(batch => batch.id === batchId);
}

function addSiteToBatch(session, siteData) {
    const batch = getCurrentBatch(session);
    if (!batch) {
        return false;
    }
    
    // Initialize global site counter if it doesn't exist
    if (!session.data['globalSiteCounter']) {
        session.data['globalSiteCounter'] = 0;
    }
    
    // Assign global site number
    session.data['globalSiteCounter']++;
    siteData.globalNumber = session.data['globalSiteCounter'];
    
    siteData.batchId = batch.id;
    siteData.entryMethod = batch.entryMethod;
    siteData.addedAt = new Date().toISOString();
    batch.sites.push(siteData);
    // Rebuild global sites array from all batches to prevent duplicates
    if (!session.data['siteBatches']) {
        session.data['sites'] = [];
    } else {
        session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
    }
    return true;
}

function getSitesByBatch(session, batchId) {
    if (!session.data['siteBatches']) {
        return [];
    }
    const batch = session.data['siteBatches'].find(b => b.id === batchId);
    return batch ? batch.sites : [];
}

function getAllSites(session) {
    if (!session.data['siteBatches']) {
        return [];
    }
    return session.data['siteBatches'].flatMap(batch => batch.sites);
}

// Helper function to find a site by global number
function findSiteByGlobalNumber(session, globalNumber) {
    const allSites = getAllSites(session);
    return allSites.find(site => site.globalNumber === parseInt(globalNumber));
}

// Helper function to get the batch-relative position of a site by global number
function getBatchRelativePosition(session, globalNumber) {
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch || !currentBatch.sites) {
        return 1;
    }
    
    const siteIndex = currentBatch.sites.findIndex(site => site.globalNumber === parseInt(globalNumber));
    return siteIndex !== -1 ? siteIndex + 1 : 1;
}

// Function to clear manual entry session data for a fresh batch start
function clearManualEntrySessionData(session, startingSiteNumber) {
    // Clear batch-level settings
    delete session.data['manual-same-activity-dates'];
    delete session.data['manual-same-activity-description'];
    
    // Clear shared activity dates
    delete session.data['manual-start-date-date-input-day'];
    delete session.data['manual-start-date-date-input-month'];
    delete session.data['manual-start-date-date-input-year'];
    delete session.data['manual-end-date-date-input-day'];
    delete session.data['manual-end-date-date-input-month'];
    delete session.data['manual-end-date-date-input-year'];
    
    // Clear shared activity description
    delete session.data['manual-activity-details-text-area'];
    
    // Clear all possible site-specific data (for a wide range of potential site numbers)
    for (let siteNum = 1; siteNum <= 20; siteNum++) {
        // Site names
        if (siteNum === 1) {
            delete session.data['manual-site-name-text-input'];
        } else {
            delete session.data[`manual-site-${siteNum}-name-text-input`];
        }
        
        // Site-specific dates
        const sitePrefix = siteNum === 1 ? 'manual-' : `manual-site-${siteNum}-`;
        delete session.data[`${sitePrefix}start-date-date-input-day`];
        delete session.data[`${sitePrefix}start-date-date-input-month`];
        delete session.data[`${sitePrefix}start-date-date-input-year`];
        delete session.data[`${sitePrefix}end-date-date-input-day`];
        delete session.data[`${sitePrefix}end-date-date-input-month`];
        delete session.data[`${sitePrefix}end-date-date-input-year`];
        
        // Site-specific descriptions
        if (siteNum === 1) {
            // Note: shared description uses 'manual-activity-details-text-area', already cleared above
        } else {
            delete session.data[`manual-site-${siteNum}-activity-details-text-area`];
        }
        
        // Coordinate entry methods and systems
        delete session.data[`${sitePrefix}coordinate-entry-method`];
        delete session.data[`${sitePrefix}coordinate-system-radios`];
        
        // Coordinate data
        delete session.data[`${sitePrefix}latitude`];
        delete session.data[`${sitePrefix}longitude`];
        delete session.data[`${sitePrefix}site-width`];
        
        // Multiple coordinates
        for (let i = 1; i <= 5; i++) {
            delete session.data[`${sitePrefix}coordinates-point-${i}-latitude`];
            delete session.data[`${sitePrefix}coordinates-point-${i}-longitude`];
        }
    }
    
    // Clear any error states
    delete session.data['errorthispage'];
    delete session.data['errortypeone'];
    delete session.data['errortypetwo'];
    delete session.data['startdateerror'];
    delete session.data['enddateerror'];
    delete session.data['errors'];
}

// LEGACY CODE REMOVED: populateSessionDataFromSite function
// This was replaced by the unified model's site object approach - sites maintain their own data

// NEW: Initialize new sites with inherited data from batch settings
function initializeNewSiteWithInheritedData(session, newSite) {
    console.log(`=== INITIALIZING SITE ${newSite.globalNumber} WITH INHERITED DATA ===`);
    
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch || !currentBatch.settings) {
        console.log('No batch settings found for data inheritance');
        return;
    }
    
    // Apply same activity dates if they exist
    if (currentBatch.settings.sameActivityDates === 'Yes' && currentBatch.settings.sharedStartDate) {
        newSite.activityDates = {
            startDate: { ...currentBatch.settings.sharedStartDate },
            endDate: { ...currentBatch.settings.sharedEndDate }
        };
        console.log(`Inherited shared activity dates for site ${newSite.globalNumber}`);
    }
    
    // Apply same activity description if it exists
    if (currentBatch.settings.sameActivityDescription === 'Yes' && currentBatch.settings.sharedDescription) {
        newSite.activityDetails = currentBatch.settings.sharedDescription;
        console.log(`Inherited shared activity description for site ${newSite.globalNumber}`);
    }
    
    console.log(`=== INHERITANCE COMPLETE FOR SITE ${newSite.globalNumber} ===`);
}

// Helper function to clear session data that might contaminate between sites
function clearCurrentSiteSessionData(session) {
    console.log('=== CLEARING CURRENT SITE SESSION DATA ===');
    
    // Clear session data that might persist between sites
    const keysToClear = [
        'manual-site-name-text-input',
        'coordinates-latitude',
        'coordinates-longitude',
        'activity-details-text-area',
        'site-width',
        'coordinate-format',
        'manual-coordinate-entry-method',
        'manual-coordinate-system-radios'
    ];
    
    let clearedCount = 0;
    keysToClear.forEach(key => {
        if (session.data[key]) {
            delete session.data[key];
            clearedCount++;
            console.log(`Cleared session key: ${key}`);
        }
    });
    
    console.log(`=== CLEARED ${clearedCount} SESSION KEYS ===`);
}

// ===== MIGRATED: Does your project involve more than one site? - GET route =====
router.get('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site', function (req, res) {
    // Initialize unified model
    migrateToUnifiedModel(req.session);
    
    res.render(version + section + 'manual-entry/does-your-project-involve-more-than-one-site', {
        data: req.session.data,
        errors: {}
    });
});

// ===== MIGRATED: Does your project involve more than one site? - POST route =====
router.post('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site-router', function (req, res) {
    const selection = req.body['manual-multiple-sites'];

    if (!selection) {
        return res.render(version + section + 'manual-entry/does-your-project-involve-more-than-one-site', {
            data: req.session.data,
            errors: { 'multipleSites': 'Please select whether your project involves more than one site' }
        });
    }

    // Initialize a new batch for this manual entry session
    const batchId = initializeBatch(req.session, 'manual-entry');
    req.session.data['currentBatchId'] = batchId;
    
    // Clear any previous manual entry session data
    clearManualEntrySessionData(req.session, 1);

    // Route based on selection - both Yes and No go to site-name with global site number
    const nextGlobalSiteNumber = (req.session.data['globalSiteCounter'] || 0) + 1;
    res.redirect('site-name?site=' + nextGlobalSiteNumber);
});

// NEW: Unified model approach for site name
router.get('/' + version + section + 'manual-entry/site-name', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    // Initialize unified model
    if (typeof migrateToUnifiedModel === 'function') {
        migrateToUnifiedModel(req.session);
    }
    
    let site = null;
    let isEditing = false;
    
    if (siteParam && returnTo === 'review-site-details') {
        // Editing existing site - find by global number
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
        isEditing = !!site;
        console.log(`Editing mode: ${isEditing}, site found: ${!!site}`);
    }
    
    if (!site) {
        // Creating new site
        site = createNewSite(req.session);
        console.log(`Created new site for manual entry: ${site.id}`);
        
        // Auto-populate shared data if this isn't the first site
        if (site.globalNumber > 1) {
            initializeNewSiteWithInheritedData(req.session, site);
        }
    }
    
    // Store current site ID in session for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'site-name'), {
        data: req.session.data,
        site: site,
        isEditing: isEditing,
        errors: site.validationErrors || {}
    });
});

// NEW: Unified model POST handler for site name
router.post('/' + version + section + 'manual-entry/site-name-router', function (req, res) {
    const siteName = req.body['site-name'];
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    console.log(`Processing site name: "${siteName}" for site: ${siteId}`);
    
    if (!siteId) {
        console.log('No current site ID found');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update site in unified model
    const success = updateSiteField(req.session, siteId, 'name', siteName || '');
    if (!success) {
        console.log('Failed to update site name');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Validate the field
    const site = findSiteById(req.session, siteId);
    const isValid = validateSiteData(site, 'name');
    
    if (!isValid) {
        console.log('Site name validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'site-name'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Clear any previous errors for this field
    if (site.validationErrors.name) {
        delete site.validationErrors.name;
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        // Return to review page
        console.log(`🔄 Navigation: Returning to review page for site ${site.globalNumber}`);
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        // FIXED: Continue to proper next step in flow - activity dates, not coordinates
        // Check if this is a single site or multiple site flow
        const multiSiteChoice = req.session.data['manual-multiple-sites'];
        console.log(`🧭 Navigation: Site name complete for site ${site.globalNumber}, multiSiteChoice: ${multiSiteChoice}`);
        
        if (multiSiteChoice === 'No') {
            // Single site flow: go to individual activity dates
            console.log(`🔀 Navigation: Single site flow → individual-site-activity-dates`);
            res.redirect('/' + version + section + 'manual-entry/individual-site-activity-dates?site=' + site.globalNumber);
        } else {
            // Multiple site flow: check if shared activity dates question was answered
            const currentBatch = getCurrentBatch(req.session);
            const hasSharedActivityDatesAnswer = currentBatch && 
                currentBatch.settings && 
                currentBatch.settings.sameActivityDates;
            
            console.log(`🔀 Navigation: Multiple site flow, hasSharedActivityDatesAnswer: ${hasSharedActivityDatesAnswer}`);
            
            if (!hasSharedActivityDatesAnswer) {
                // Need to ask about shared activity dates first
                console.log(`🔀 Navigation: Multiple site flow → same-activity-dates (first time)`);
                res.redirect('/' + version + section + 'manual-entry/same-activity-dates');
            } else if (currentBatch.settings.sameActivityDates === 'Yes') {
                // Shared dates - go to activity dates (all sites)
                console.log(`🔀 Navigation: Multiple site flow → activity-dates (shared dates)`);
                res.redirect('/' + version + section + 'manual-entry/activity-dates');
            } else {
                // Individual dates - go to individual activity dates
                console.log(`🔀 Navigation: Multiple site flow → individual-site-activity-dates (individual dates)`);
                res.redirect('/' + version + section + 'manual-entry/individual-site-activity-dates?site=' + site.globalNumber);
            }
        }
    }
});

// ===== MIGRATED: same-activity-dates routes to unified model =====

// Are the activity dates the same for every site? - GET route
router.get('/' + version + section + 'manual-entry/same-activity-dates', function (req, res) {
    // Initialize unified model
    migrateToUnifiedModel(req.session);
    
    const returnTo = req.query.returnTo;
    
    // Get or create current batch for flow control data
    let currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        currentBatch = initializeBatch(req.session, 'manual-entry');
    }
    
    res.render(version + section + 'manual-entry/same-activity-dates', {
        data: req.session.data,
        currentBatch: currentBatch,
        returnTo: returnTo,
        errors: {}
    });
});

// Are the activity dates the same for every site? - POST route
router.post('/' + version + section + 'manual-entry/same-activity-dates-router', function (req, res) {
    const selection = req.body['manual-same-activity-dates'];
    const returnTo = req.query.returnTo;

    if (!selection) {
        const currentBatch = getCurrentBatch(req.session);
        return res.render(version + section + 'manual-entry/same-activity-dates', {
            data: req.session.data,
            currentBatch: currentBatch,
            returnTo: returnTo,
            errors: { 'sameActivityDates': 'Please select an option' }
        });
    }

    // Store the selection in batch settings
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch) {
        if (!currentBatch.settings) {
            currentBatch.settings = {};
        }
        currentBatch.settings.sameActivityDates = selection;
    }

    // If returning from review, handle shared date updates
    if (returnTo === 'review-site-details') {
        if (selection === "No" && currentBatch.settings.sameActivityDates === "Yes") {
            // Copy shared dates to all unified sites
            const sharedStartDate = currentBatch.settings.sharedStartDate;
            const sharedEndDate = currentBatch.settings.sharedEndDate;
            
            if (sharedStartDate && req.session.data['unifiedSites']) {
                req.session.data['unifiedSites'].forEach(site => {
                    if (site.source === 'manual-entry') {
                        updateSiteField(req.session, site.id, 'activityDates.startDate', sharedStartDate);
                        updateSiteField(req.session, site.id, 'activityDates.endDate', sharedEndDate);
                    }
                });
            }
        }
        
        return res.redirect('review-site-details');
    }

    // Route based on selection - FIX: Add site parameter to all redirects
    const currentSiteId = req.session.data['currentManualEntrySiteId'];
    const currentSite = findSiteById(req.session, currentSiteId);
    const siteNumber = currentSite ? currentSite.globalNumber : 1;
    
    switch(selection) {
        case "Yes":
            res.redirect('activity-dates?site=' + siteNumber);
            break;
        case "No":
            res.redirect('individual-site-activity-dates?site=' + siteNumber);
            break;
        default:
            res.redirect('same-activity-dates?site=' + siteNumber);
    }
});

// NEW: Unified model individual site activity dates GET route
router.get('/' + version + section + 'manual-entry/individual-site-activity-dates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for individual activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for individual activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-dates'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// NEW: Unified model individual site activity dates POST route
router.post('/' + version + section + 'manual-entry/individual-site-activity-dates-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== INDIVIDUAL ACTIVITY DATES FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const startDay = req.body['start-date-date-input-day'];
    const startMonth = req.body['start-date-date-input-month'];
    const startYear = req.body['start-date-date-input-year'];
    
    const endDay = req.body['end-date-date-input-day'];
    const endMonth = req.body['end-date-date-input-month'];
    const endYear = req.body['end-date-date-input-year'];
    
    console.log(`Processing individual activity dates for site: ${siteId}`);
    console.log(`Extracted dates - Start: ${startDay}/${startMonth}/${startYear}, End: ${endDay}/${endMonth}/${endYear}`);
    
    if (!siteId) {
        console.log('No current site ID found for individual activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for individual activity dates update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update activity dates in unified model
    updateSiteField(req.session, siteId, 'activityDates.startDate.day', startDay || '');
    updateSiteField(req.session, siteId, 'activityDates.startDate.month', startMonth || '');
    updateSiteField(req.session, siteId, 'activityDates.startDate.year', startYear || '');
    updateSiteField(req.session, siteId, 'activityDates.endDate.day', endDay || '');
    updateSiteField(req.session, siteId, 'activityDates.endDate.month', endMonth || '');
    updateSiteField(req.session, siteId, 'activityDates.endDate.year', endYear || '');
    
    // Validate activity dates
    const isValid = validateSiteData(site, 'activityDates');
    
    if (!isValid) {
        console.log('Individual activity dates validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-dates'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Clear date-related errors
    ['startDate', 'endDate'].forEach(field => {
        if (site.validationErrors[field]) {
            delete site.validationErrors[field];
        }
    });
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        // Check if this is a single site batch or continue with flow
        res.redirect('/' + version + section + 'manual-entry/individual-site-activity-description?site=' + site.globalNumber);
    }
});

// NEW: Unified model activity dates GET route
router.get('/' + version + section + 'manual-entry/activity-dates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Check if this site should inherit data from shared settings
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings && currentBatch.settings.sameActivityDates === 'Yes' && currentBatch.settings.sharedStartDate) {
        // Auto-populate if current site doesn't have dates yet
        if (!site.activityDates.startDate.day && !site.activityDates.endDate.day) {
            site.activityDates = {
                startDate: { ...currentBatch.settings.sharedStartDate },
                endDate: { ...currentBatch.settings.sharedEndDate }
            };
            console.log(`Auto-populated activity dates for site ${site.globalNumber} from shared settings`);
        }
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'activity-dates'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// NEW: Unified model activity dates POST route
router.post('/' + version + section + 'manual-entry/activity-dates-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== ACTIVITY DATES FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const startDay = req.body['start-date-date-input-day'];
    const startMonth = req.body['start-date-date-input-month'];
    const startYear = req.body['start-date-date-input-year'];
    
    const endDay = req.body['end-date-date-input-day'];
    const endMonth = req.body['end-date-date-input-month'];
    const endYear = req.body['end-date-date-input-year'];
    
    console.log(`Processing activity dates for site: ${siteId}`);
    console.log(`Extracted dates - Start: ${startDay}/${startMonth}/${startYear}, End: ${endDay}/${endMonth}/${endYear}`);
    
    if (!siteId) {
        console.log('No current site ID found for activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for activity dates update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update activity dates in unified model
    updateSiteField(req.session, siteId, 'activityDates.startDate.day', startDay || '');
    updateSiteField(req.session, siteId, 'activityDates.startDate.month', startMonth || '');
    updateSiteField(req.session, siteId, 'activityDates.startDate.year', startYear || '');
    updateSiteField(req.session, siteId, 'activityDates.endDate.day', endDay || '');
    updateSiteField(req.session, siteId, 'activityDates.endDate.month', endMonth || '');
    updateSiteField(req.session, siteId, 'activityDates.endDate.year', endYear || '');
    
    // Store shared dates in batch settings (for multi-site data sharing)
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings && currentBatch.settings.sameActivityDates === 'Yes') {
        currentBatch.settings.sharedStartDate = {
            day: startDay || '',
            month: startMonth || '',
            year: startYear || ''
        };
        currentBatch.settings.sharedEndDate = {
            day: endDay || '',
            month: endMonth || '',
            year: endYear || ''
        };
        
        // Copy to all existing unified sites
        if (req.session.data['unifiedSites']) {
            req.session.data['unifiedSites'].forEach(existingSite => {
                if (existingSite.source === 'manual-entry') {
                    updateSiteField(req.session, existingSite.id, 'activityDates.startDate.day', startDay || '');
                    updateSiteField(req.session, existingSite.id, 'activityDates.startDate.month', startMonth || '');
                    updateSiteField(req.session, existingSite.id, 'activityDates.startDate.year', startYear || '');
                    updateSiteField(req.session, existingSite.id, 'activityDates.endDate.day', endDay || '');
                    updateSiteField(req.session, existingSite.id, 'activityDates.endDate.month', endMonth || '');
                    updateSiteField(req.session, existingSite.id, 'activityDates.endDate.year', endYear || '');
                }
            });
        }
        console.log('Stored shared activity dates for all sites');
    }
    
    // Validate activity dates
    const isValid = validateSiteData(site, 'activityDates');
    
    if (!isValid) {
        console.log('Activity dates validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'activity-dates'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Clear date-related errors
    ['startDate', 'endDate'].forEach(field => {
        if (site.validationErrors[field]) {
            delete site.validationErrors[field];
        }
    });
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        res.redirect('/' + version + section + 'manual-entry/activity-description?site=' + site.globalNumber);
    }
});

// ===== MIGRATED: same-activity-description routes to unified model =====

// Are the activity descriptions the same for every site? - GET route
router.get('/' + version + section + 'manual-entry/same-activity-description', function (req, res) {
    // Initialize unified model
    migrateToUnifiedModel(req.session);
    
    const returnTo = req.query.returnTo;
    
    // Get or create current batch for flow control data
    let currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        currentBatch = initializeBatch(req.session, 'manual-entry');
    }
    
    res.render(version + section + 'manual-entry/same-activity-description', {
        data: req.session.data,
        currentBatch: currentBatch,
        returnTo: returnTo,
        errors: {}
    });
});

// Are the activity descriptions the same for every site? - POST route
router.post('/' + version + section + 'manual-entry/same-activity-description-router', function (req, res) {
    const selection = req.body['manual-same-activity-description'];
    const returnTo = req.query.returnTo;

    if (!selection) {
        const currentBatch = getCurrentBatch(req.session);
        return res.render(version + section + 'manual-entry/same-activity-description', {
            data: req.session.data,
            currentBatch: currentBatch,
            returnTo: returnTo,
            errors: { 'sameActivityDescription': 'Please select an option' }
        });
    }

    // Store the selection in batch settings
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch) {
        if (!currentBatch.settings) {
            currentBatch.settings = {};
        }
        currentBatch.settings.sameActivityDescription = selection;
    }

    // If returning from review, handle shared description updates
    if (returnTo === 'review-site-details') {
        if (selection === "No" && currentBatch.settings.sameActivityDescription === "Yes") {
            // Copy shared description to all unified sites
            const sharedDescription = currentBatch.settings.sharedDescription;
            
            if (sharedDescription && req.session.data['unifiedSites']) {
                req.session.data['unifiedSites'].forEach(site => {
                    if (site.source === 'manual-entry') {
                        updateSiteField(req.session, site.id, 'activityDetails', sharedDescription);
                    }
                });
            }
        }
        
        return res.redirect('review-site-details');
    }

    // Route based on selection - FIX: Add site parameter to all redirects
    const currentSiteId = req.session.data['currentManualEntrySiteId'];
    const currentSite = findSiteById(req.session, currentSiteId);
    const siteNumber = currentSite ? currentSite.globalNumber : 1;
    
    switch(selection) {
        case "Yes":
            res.redirect('activity-description?site=' + siteNumber);
            break;
        case "No":
            res.redirect('individual-site-activity-description?site=' + siteNumber);
            break;
        default:
            res.redirect('same-activity-description?site=' + siteNumber);
    }
});

// NEW: Unified model individual site activity description GET route
router.get('/' + version + section + 'manual-entry/individual-site-activity-description', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for individual activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for individual activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-description'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {},
        currentSiteFromRoute: site.globalNumber
    });
});

// NEW: Unified model individual site activity description POST route
router.post('/' + version + section + 'manual-entry/individual-site-activity-description-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== INDIVIDUAL ACTIVITY DESCRIPTION FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const description = req.body['activity-details-text-area'];
    
    console.log(`Processing individual activity description for site: ${siteId}`);
    console.log(`Extracted description: "${description}"`);
    
    if (!siteId) {
        console.log('No current site ID found for individual activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for individual activity description update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update activity description in unified model
    updateSiteField(req.session, siteId, 'activityDetails', description || '');
    
    // Validate activity description
    const isValid = validateSiteData(site, 'activityDetails');
    
    if (!isValid) {
        console.log('Individual activity description validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-description'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors,
            currentSiteFromRoute: site.globalNumber
        });
    }
    
    // Clear description-related errors
    if (site.validationErrors.activityDetails) {
        delete site.validationErrors.activityDetails;
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        res.redirect('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates?site=' + site.globalNumber);
    }
});

// NEW: Unified model activity description GET route
router.get('/' + version + section + 'manual-entry/activity-description', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Check if this site should inherit description from shared settings
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings && currentBatch.settings.sameActivityDescription === 'Yes' && currentBatch.settings.sharedDescription) {
        // Auto-populate if current site doesn't have description yet
        if (!site.activityDetails || site.activityDetails.trim() === '') {
            site.activityDetails = currentBatch.settings.sharedDescription;
            console.log(`Auto-populated activity description for site ${site.globalNumber} from shared settings`);
        }
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'activity-description'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// NEW: Unified model activity description POST route
router.post('/' + version + section + 'manual-entry/activity-description-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== ACTIVITY DESCRIPTION FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const description = req.body['activity-details-text-area'];
    
    console.log(`Processing activity description for site: ${siteId}`);
    console.log(`Extracted description: "${description}"`);
    
    if (!siteId) {
        console.log('No current site ID found for activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for activity description update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update activity description in unified model
    updateSiteField(req.session, siteId, 'activityDetails', description || '');
    
    // Store shared description in batch settings (for multi-site data sharing)
    const currentBatch = getCurrentBatch(req.session);
    if (currentBatch && currentBatch.settings && currentBatch.settings.sameActivityDescription === 'Yes') {
        currentBatch.settings.sharedDescription = description || '';
        
        // Copy to all existing unified sites
        if (req.session.data['unifiedSites']) {
            req.session.data['unifiedSites'].forEach(existingSite => {
                if (existingSite.source === 'manual-entry') {
                    updateSiteField(req.session, existingSite.id, 'activityDetails', description || '');
                }
            });
        }
        console.log('Stored shared activity description for all sites');
    }
    
    // Validate activity description
    const isValid = validateSiteData(site, 'activityDetails');
    
    if (!isValid) {
        console.log('Activity description validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'activity-description'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Clear description-related errors
    if (site.validationErrors.activityDetails) {
        delete site.validationErrors.activityDetails;
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        res.redirect('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates?site=' + site.globalNumber);
    }
});

// ===== MIGRATED: coordinate entry method routes to unified model =====

// How do you want to enter the coordinates? - GET route
router.get('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for coordinate entry method');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for coordinate entry method');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates', {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// How do you want to enter the coordinates? - POST route
router.post('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    const selection = req.body['manual-coordinate-entry-method'];
    
    console.log(`Processing coordinate entry method for site: ${siteId}, selection: ${selection}`);
    
    if (!siteId) {
        console.log('No current site ID found for coordinate entry method');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for coordinate entry method update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    if (!selection) {
        site.validationErrors = { ...site.validationErrors, coordinateEntryMethod: 'Please select how you want to enter coordinates' };
        return res.render(version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates', {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Update coordinate entry method and clear previous coordinate data
    updateSiteField(req.session, siteId, 'coordinates.entryMethod', selection);
    
    // Set coordinate type based on selection
    if (selection === "Enter one set of coordinates and a width to create a circular site") {
        updateSiteField(req.session, siteId, 'coordinates.type', 'circle');
    } else if (selection === "Enter multiple sets of coordinates to mark the boundary of the site") {
        updateSiteField(req.session, siteId, 'coordinates.type', 'polygon');
    }
    
    // Clear coordinate-related errors
    if (site.validationErrors.coordinateEntryMethod) {
        delete site.validationErrors.coordinateEntryMethod;
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        res.redirect('/' + version + section + 'manual-entry/which-coordinate-system?site=' + site.globalNumber);
    }
});

// ===== MIGRATED: coordinate system routes to unified model =====

// Which coordinate system? - GET route
router.get('/' + version + section + 'manual-entry/which-coordinate-system', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for coordinate system');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for coordinate system');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(version + section + 'manual-entry/which-coordinate-system', {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// Which coordinate system? - POST route
router.post('/' + version + section + 'manual-entry/which-coordinate-system-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    const selection = req.body['manual-coordinate-system-radios'];
    
    console.log(`Processing coordinate system for site: ${siteId}, selection: ${selection}`);
    
    if (!siteId) {
        console.log('No current site ID found for coordinate system');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for coordinate system update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    if (!selection) {
        site.validationErrors = { ...site.validationErrors, coordinateSystem: 'Please select a coordinate system' };
        return res.render(version + section + 'manual-entry/which-coordinate-system', {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Update coordinate system
    updateSiteField(req.session, siteId, 'coordinates.system', selection);
    
    // Set coordinate format based on system
    if (selection === 'WGS84') {
        updateSiteField(req.session, siteId, 'coordinates.format', 'decimal-degrees');
    } else {
        updateSiteField(req.session, siteId, 'coordinates.format', 'degrees-minutes-seconds');
    }
    
    // Clear coordinate system errors
    if (site.validationErrors.coordinateSystem) {
        delete site.validationErrors.coordinateSystem;
    }
    
    // Determine next step based on coordinate type
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        if (site.coordinates && site.coordinates.type === 'polygon') {
            res.redirect('/' + version + section + 'manual-entry/enter-multiple-coordinates?site=' + site.globalNumber);
        } else {
            res.redirect('/' + version + section + 'manual-entry/enter-coordinates?site=' + site.globalNumber);
        }
    }
});

// NEW: Unified model coordinates GET route
router.get('/' + version + section + 'manual-entry/enter-coordinates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for coordinates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for coordinates entry');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'enter-coordinates'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// Enter multiple coordinates - GET route
router.get('/' + version + section + 'manual-entry/enter-multiple-coordinates', function (req, res) {
    req.session.data['errorthispage'] = "false";
    req.session.data['errortypeone'] = "false";
    req.session.data['errors'] = [];
    
    // Get site number from query parameter
    const siteNumber = req.query.site || 1;
    const returnTo = req.query.returnTo;
    
    // Store returnTo in session for use in POST route
    if (returnTo) {
        req.session.data['returnTo'] = returnTo;
    }
    
    // Determine if we're editing an existing site or creating a new one
    const isEditingExistingSite = returnTo === 'review-site-details';
    
    let batchRelativePosition;
    
    if (isEditingExistingSite) {
        // We're editing an existing site - siteNumber is a global number
        batchRelativePosition = getBatchRelativePosition(req.session, parseInt(siteNumber));
        
        // DON'T populate session data when editing - it overwrites fresh changes
        // The session already has the data from the editing flow
    } else {
        // We're creating a new site - siteNumber is a batch-relative number
        batchRelativePosition = parseInt(siteNumber);
    }
    
    req.session.data['current-site'] = batchRelativePosition;
    
    // Check if we're returning from review-site-details
    if (returnTo === 'review-site-details') {
        req.session.data['fromReviewSiteDetails'] = 'true';
    }
    
    res.render(version + section + 'manual-entry/enter-multiple-coordinates');
});

// NEW: Unified model coordinates POST route
router.post('/' + version + section + 'manual-entry/enter-coordinates-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for coordinates update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // FIXED: Get coordinates from form using correct field names from template
    const latitude = req.body['coordinates-latitude'];
    const longitude = req.body['coordinates-longitude'];
    const format = req.body['coordinate-format'] || 'decimal-degrees';
    
    console.log(`📍 Processing coordinates for site: ${siteId}`);
    console.log(`📍 Form body received:`, req.body);
    console.log(`📍 Extracted - Lat: ${latitude}, Lon: ${longitude}, Format: ${format}`);
    
    if (!siteId) {
        console.log('No current site ID found for coordinates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update coordinates in unified model
    updateSiteField(req.session, siteId, 'coordinates.latitude', latitude || '');
    updateSiteField(req.session, siteId, 'coordinates.longitude', longitude || '');
    updateSiteField(req.session, siteId, 'coordinates.format', format);
    
    // Validate coordinates
    const isValid = validateSiteData(site, 'coordinates');
    
    if (!isValid) {
        console.log('Coordinates validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'enter-coordinates'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }
    
    // Clear coordinate-related errors
    ['latitude', 'longitude'].forEach(field => {
        if (site.validationErrors[field]) {
            delete site.validationErrors[field];
        }
    });
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        // FIXED: Route based on coordinate entry method
        if (site.coordinates.type === 'circle') {
            // Circular site - need to get width
            res.redirect('/' + version + section + 'manual-entry/site-width?site=' + site.globalNumber);
        } else if (site.coordinates.type === 'polygon') {
            // Polygon site - need multiple coordinates (not implemented in this route)
            res.redirect('/' + version + section + 'manual-entry/enter-multiple-coordinates?site=' + site.globalNumber);
        } else {
            // Fallback - assume circular if not set
            res.redirect('/' + version + section + 'manual-entry/site-width?site=' + site.globalNumber);
        }
    }
});

// NEW: Unified model site width GET route
router.get('/' + version + section + 'manual-entry/site-width', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for site width');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    let site;
    if (returnTo === 'review-site-details') {
        // Editing existing site
        site = findSiteByGlobalNumberUnified(req.session, siteParam);
    } else {
        // Continue with current site
        const siteId = req.session.data['currentManualEntrySiteId'];
        site = findSiteById(req.session, siteId);
    }
    
    if (!site) {
        console.log('Site not found for site width');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update current site ID for form processing
    req.session.data['currentManualEntrySiteId'] = site.id;
    
    res.render(path.join(version, section, 'manual-entry', 'site-width'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        errors: site.validationErrors || {}
    });
});

// NEW: Unified model site width POST route
router.post('/' + version + section + 'manual-entry/site-width-router', function (req, res) {
    const siteId = req.session.data['currentManualEntrySiteId'];
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== SITE WIDTH FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const width = req.body['site-width'];
    
    console.log(`Processing site width for site: ${siteId}`);
    console.log(`Extracted width: "${width}"`);
    
    if (!siteId) {
        console.log('No current site ID found for site width');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    const site = findSiteById(req.session, siteId);
    if (!site) {
        console.log('Site not found for site width update');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Update site width in unified model
    updateSiteField(req.session, siteId, 'coordinates.width', width || '');
    
    // Validate site width (only if provided)
    if (width && width.trim() !== '') {
        const isValid = validateSiteData(site, 'siteWidth');
        
        if (!isValid) {
            console.log('Site width validation failed:', site.validationErrors);
            return res.render(path.join(version, section, 'manual-entry', 'site-width'), {
                data: req.session.data,
                site: site,
                isEditing: returnTo === 'review-site-details',
                errors: site.validationErrors
            });
        }
    }
    
    // Clear width-related errors
    if (site.validationErrors.siteWidth) {
        delete site.validationErrors.siteWidth;
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'review-site-details?site=' + site.globalNumber);
    } else {
        res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber);
    }
});

// Review site details - GET route
router.get('/' + version + section + 'manual-entry/review-site-details', function (req, res) {
    console.log('=== REVIEW SITE DETAILS DEBUG ===');
    req.session.data['errorthispage'] = "false";
    req.session.data['errors'] = [];
    
    // If we have a batchId query parameter, set it as current batch
    if (req.query.batchId) {
        req.session.data['currentBatchId'] = req.query.batchId;
        console.log('Set currentBatchId from query:', req.query.batchId);
    }
    
    console.log('Current session activity settings:', {
        'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
        'manual-same-activity-description': req.session.data['manual-same-activity-description'],
        'manual-start-date-date-input-day': req.session.data['manual-start-date-date-input-day'],
        'manual-activity-details-text-area': req.session.data['manual-activity-details-text-area']
    });
    
    // Only convert manual entry sites to unified format when we don't have an existing batch
    // If we already have a batch with sites, preserve it to avoid overwriting edits
    if (!req.session.data['currentBatchId'] || !getCurrentBatch(req.session)) {
        console.log('No current batch found, converting manual sites to unified format');
        convertManualSitesToUnifiedFormat(req);
    } else {
        const currentBatch = getCurrentBatch(req.session);
        if (currentBatch && currentBatch.sites && currentBatch.sites.length > 0) {
            console.log('Current batch with sites exists, preserving to avoid overwriting edits');
        } else {
            console.log('Current batch exists but no sites, converting to pick up any new sites');
            convertManualSitesToUnifiedFormat(req);
        }
    }
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    console.log('Current batch after conversion:', currentBatch ? {
        id: currentBatch.id,
        sitesCount: currentBatch.sites.length,
        settings: currentBatch.settings
    } : 'null');
    
    // Determine if we're in active editing mode or reviewing a saved batch
    const isActiveEditing = !req.query.batchId || req.session.data['siteDetailsSaved'] !== true;
    console.log('Is active editing:', isActiveEditing);
    
    // If we're reviewing a saved batch, populate session data from batch settings
    if (currentBatch && currentBatch.settings && req.query.batchId) {
        console.log('Populating session data from batch settings...');
        // Populate activity settings from batch
        req.session.data['manual-same-activity-dates'] = currentBatch.settings.sameActivityDates;
        req.session.data['manual-same-activity-description'] = currentBatch.settings.sameActivityDescription;
        
        // Populate shared dates from batch
        if (currentBatch.settings.sharedStartDate) {
            req.session.data['manual-start-date-date-input-day'] = currentBatch.settings.sharedStartDate.day;
            req.session.data['manual-start-date-date-input-month'] = currentBatch.settings.sharedStartDate.month;
            req.session.data['manual-start-date-date-input-year'] = currentBatch.settings.sharedStartDate.year;
        }
        
        if (currentBatch.settings.sharedEndDate) {
            req.session.data['manual-end-date-date-input-day'] = currentBatch.settings.sharedEndDate.day;
            req.session.data['manual-end-date-date-input-month'] = currentBatch.settings.sharedEndDate.month;
            req.session.data['manual-end-date-date-input-year'] = currentBatch.settings.sharedEndDate.year;
        }
        
        // Populate shared description from batch
        if (currentBatch.settings.sharedDescription) {
            req.session.data['manual-activity-details-text-area'] = currentBatch.settings.sharedDescription;
        }
        
        console.log('Session data after populating from batch:', {
            'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
            'manual-same-activity-description': req.session.data['manual-same-activity-description']
        });
        
        // NOTE: We don't populate session data from batch sites here because:
        // 1. The template reads from the sites array (batch data), not session data
        // 2. Session data should only be populated when editing forms
        // 3. Populating here overwrites fresh session data with old batch data
        
        // Update current site number to match the batch
        if (currentBatch.sites && currentBatch.sites.length > 0) {
            req.session.data['manual-current-site'] = currentBatch.sites.length;
        }
    }
    
    // Only pass the current batch's sites to the template
    let sites = [];
    if (typeof getCurrentBatch === 'function') {
        const batch = getCurrentBatch(req.session);
        if (batch) {
            sites = batch.sites;
        }
    }
    
    console.log('Final sites to render:', sites.length);
    console.log('Final session activity settings for template:', {
        'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
        'manual-same-activity-description': req.session.data['manual-same-activity-description']
    });
    
    // Get the current batch to pass to template
    const batchForTemplate = getCurrentBatch(req.session);
    
    console.log('=== END REVIEW SITE DETAILS DEBUG ===');
    
    res.render(version + section + 'manual-entry/review-site-details', { 
        sites,
        isActiveEditing,
        currentBatch: batchForTemplate
    });
});

// Review site details - POST route
router.post('/' + version + section + 'manual-entry/review-site-details-router', function (req, res) {
    // Convert manual entry sites to unified format when saving to ensure they're in the global sites array
    convertManualSitesToUnifiedFormat(req);
    
    // Use the existing current batch for completeness checks
    let hasSiteIncomplete = false;
    let sites = [];
    if (typeof getCurrentBatch === 'function') {
        const batch = getCurrentBatch(req.session);
        if (batch) {
            sites = batch.sites;
        }
    }
    if (sites.length > 0) {
        for (const site of sites) {
            if (!site.name) {
                hasSiteIncomplete = true;
            }
            if (req.session.data['manual-same-activity-dates'] === "No") {
                if (!site.startDate || !site.startDate.day) {
                    hasSiteIncomplete = true;
                }
            }
            if (req.session.data['manual-same-activity-description'] === "No") {
                if (!site.description) {
                    hasSiteIncomplete = true;
                }
            }
        }
        if (hasSiteIncomplete) {
            req.session.data['exempt-information-3-status'] = 'in-progress';
        } else {
            req.session.data['exempt-information-3-status'] = 'completed';
        }
    } else {
        req.session.data['exempt-information-3-status'] = 'cannot-start';
    }
    
    // Mark the task as completed and clear the current batch ID so we can start fresh next time
    req.session.data['siteDetailsSaved'] = true;
    delete req.session.data['currentBatchId'];
    
    // Check if we came from check answers page
    if (req.session.data['camefromcheckanswers'] === 'true') {
        req.session.data['camefromcheckanswers'] = false;
        res.redirect('../check-answers-multiple-sites');
    } else {
        // Redirect to site-details-added (Your sites page)
        res.redirect('../site-details-added');
    }
});

// Function to convert manual entry sites to unified format
function convertManualSitesToUnifiedFormat(req) {
    console.log('=== CONVERT MANUAL SITES TO UNIFIED FORMAT DEBUG ===');
    
    // Get the current site number from session
    const currentSiteNumber = parseInt(req.session.data['manual-current-site']) || 1;
    console.log('Current site number from session:', currentSiteNumber);
    
    // Only initialize a new batch if we don't already have a current batch
    let batchId = req.session.data['currentBatchId'];
    if (!batchId || !getCurrentBatch(req.session)) {
        console.log('Initializing new batch for manual entry');
        batchId = initializeBatch(req.session, 'manual-entry');
        req.session.data['currentBatchId'] = batchId;
    } else {
        console.log('Using existing batch:', batchId);
    }
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('ERROR: Could not get current batch');
        return;
    }
    
    console.log('Session activity settings before storing in batch:', {
        'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
        'manual-same-activity-description': req.session.data['manual-same-activity-description'],
        'manual-start-date-date-input-day': req.session.data['manual-start-date-date-input-day'],
        'manual-activity-details-text-area': req.session.data['manual-activity-details-text-area']
    });
    
    // Store batch-level settings in the batch metadata
    // FIXED: Don't overwrite existing batch settings with empty session data
    if (!currentBatch.settings) {
        currentBatch.settings = {};
    }
    
    // Only update settings if we have valid session data, otherwise preserve existing
    if (req.session.data['manual-same-activity-dates']) {
        currentBatch.settings.sameActivityDates = req.session.data['manual-same-activity-dates'];
    }
    if (req.session.data['manual-same-activity-description']) {
        currentBatch.settings.sameActivityDescription = req.session.data['manual-same-activity-description'];
    }
    if (req.session.data['manual-start-date-date-input-day']) {
        currentBatch.settings.sharedStartDate = {
            day: req.session.data['manual-start-date-date-input-day'],
            month: req.session.data['manual-start-date-date-input-month'],
            year: req.session.data['manual-start-date-date-input-year']
        };
    }
    if (req.session.data['manual-end-date-date-input-day']) {
        currentBatch.settings.sharedEndDate = {
            day: req.session.data['manual-end-date-date-input-day'],
            month: req.session.data['manual-end-date-date-input-month'],
            year: req.session.data['manual-end-date-date-input-year']
        };
    }
    if (req.session.data['manual-activity-details-text-area']) {
        currentBatch.settings.sharedDescription = req.session.data['manual-activity-details-text-area'];
    }
    
    console.log('Stored batch settings:', currentBatch.settings);
    
    // Calculate the starting global number for this batch
    const globalSiteCounter = req.session.data['globalSiteCounter'] || 0;
    let batchStartingNumber = 1;
    
    // If we have existing sites, calculate where this batch should start
    if (currentBatch.sites.length === 0) {
        // New batch - start from next available global number
        batchStartingNumber = globalSiteCounter + 1;
        console.log('New batch, starting from global number:', batchStartingNumber);
    } else {
        // Existing batch - find the lowest global number in this batch
        batchStartingNumber = Math.min(...currentBatch.sites.map(site => site.globalNumber));
        console.log('Existing batch, starting from lowest global number:', batchStartingNumber);
    }
    
    // Keep track of existing sites by their global number to preserve them
    const existingSitesByGlobalNumber = {};
    currentBatch.sites.forEach(site => {
        existingSitesByGlobalNumber[site.globalNumber] = site;
    });
    
    console.log('Processing sites from', batchStartingNumber, 'to', currentSiteNumber);
    
    // Process each potential site number from the starting number to current
    for (let siteNum = batchStartingNumber; siteNum <= currentSiteNumber; siteNum++) {
        console.log(`--- Processing site ${siteNum} ---`);
        
        // Get correct field names for this site number
        const siteNameKey = siteNum === 1 ? 'manual-site-name-text-input' : `manual-site-${siteNum}-name-text-input`;
        const entryMethodKey = siteNum === 1 ? 'manual-coordinate-entry-method' : `manual-site-${siteNum}-coordinate-entry-method`;
        const coordinateSystemKey = siteNum === 1 ? 'manual-coordinate-system-radios' : `manual-site-${siteNum}-coordinate-system-radios`;
        const sitePrefix = siteNum === 1 ? 'manual-' : `manual-site-${siteNum}-`;
        
        // Only process sites that have a name
        const siteName = req.session.data[siteNameKey];
        console.log(`Site ${siteNum} name from ${siteNameKey}:`, siteName);
        
        if (!siteName) {
            console.log(`Skipping site ${siteNum} - no name found`);
            continue;
        }
        
        console.log(`Site ${siteNum} coordinate data:`, {
            latitude: req.session.data[`${sitePrefix}latitude`],
            longitude: req.session.data[`${sitePrefix}longitude`],
            width: req.session.data[`${sitePrefix}site-width`],
            coordinateSystem: req.session.data[coordinateSystemKey],
            entryMethod: req.session.data[entryMethodKey]
        });
        
        // Check if this site already exists in the batch
        let existingSite = existingSitesByGlobalNumber[siteNum];
        
        // Create or update site data object
        const siteData = existingSite ? { ...existingSite } : {
            startDate: {},
            endDate: {},
            description: ''
        };
        
        // Always update the name and other data from session
        siteData.name = siteName;
        
        // Handle dates - either shared or individual
        if (req.session.data['manual-same-activity-dates'] === 'Yes') {
            // Use shared dates
            siteData.startDate = {
                day: req.session.data['manual-start-date-date-input-day'],
                month: req.session.data['manual-start-date-date-input-month'],
                year: req.session.data['manual-start-date-date-input-year']
            };
            siteData.endDate = {
                day: req.session.data['manual-end-date-date-input-day'],
                month: req.session.data['manual-end-date-date-input-month'],
                year: req.session.data['manual-end-date-date-input-year']
            };
        } else {
            // Use site-specific dates
            const startDatePrefix = siteNum === 1 ? 'manual-' : `manual-site-${siteNum}-`;
            const sessionStartDay = req.session.data[`${startDatePrefix}start-date-date-input-day`];
            const sessionEndDay = req.session.data[`${startDatePrefix}end-date-date-input-day`];
            
            // Only overwrite existing dates if we have session data, otherwise preserve existing
            if (sessionStartDay || !existingSite || !existingSite.startDate || !existingSite.startDate.day) {
                siteData.startDate = {
                    day: sessionStartDay,
                    month: req.session.data[`${startDatePrefix}start-date-date-input-month`],
                    year: req.session.data[`${startDatePrefix}start-date-date-input-year`]
                };
            }
            if (sessionEndDay || !existingSite || !existingSite.endDate || !existingSite.endDate.day) {
                siteData.endDate = {
                    day: sessionEndDay,
                    month: req.session.data[`${startDatePrefix}end-date-date-input-month`],
                    year: req.session.data[`${startDatePrefix}end-date-date-input-year`]
                };
            }
        }
        
        // Handle description - either shared or individual
        if (req.session.data['manual-same-activity-description'] === 'Yes') {
            siteData.description = req.session.data['manual-activity-details-text-area'];
        } else {
            const descriptionKey = siteNum === 1 ? 'manual-activity-details-text-area' : `manual-site-${siteNum}-activity-details-text-area`;
            const sessionDescription = req.session.data[descriptionKey];
            
            // Only overwrite existing description if we have session data, otherwise preserve existing
            if (sessionDescription || !existingSite || !existingSite.description) {
                siteData.description = sessionDescription;
            }
        }
        
        // Add coordinates based on entry method
        const entryMethod = req.session.data[entryMethodKey];
        if (entryMethod === 'Enter one set of coordinates and a width to create a circular site') {
            siteData.coordinates = {
                type: 'circle',
                center: {
                    latitude: req.session.data[`${sitePrefix}latitude`],
                    longitude: req.session.data[`${sitePrefix}longitude`]
                },
                width: req.session.data[`${sitePrefix}site-width`]
            };
            console.log(`Site ${siteNum} set circle coordinates:`, siteData.coordinates);
        } else if (entryMethod === 'Enter multiple sets of coordinates to mark the boundary of the site') {
            siteData.coordinates = {
                type: 'polygon',
                points: []
            };
            // Add up to 5 points
            for (let i = 1; i <= 5; i++) {
                const lat = req.session.data[`${sitePrefix}coordinates-point-${i}-latitude`];
                const lng = req.session.data[`${sitePrefix}coordinates-point-${i}-longitude`];
                if (lat && lng) {
                    siteData.coordinates.points.push({
                        latitude: lat,
                        longitude: lng
                    });
                }
            }
            console.log(`Site ${siteNum} set polygon coordinates:`, siteData.coordinates);
        }
        
        // Add coordinate system
        siteData.coordinateSystem = req.session.data[coordinateSystemKey];
        
        // Add map image based on coordinate type
        if (siteData.coordinates && siteData.coordinates.type === 'circle') {
            siteData.mapImage = '/public/images/worthing-map-circle-copy.jpg';
        } else if (siteData.coordinates && siteData.coordinates.type === 'polygon') {
            const numPoints = siteData.coordinates.points.length;
            if (numPoints === 5) {
                siteData.mapImage = '/public/images/worthing-map-5-points-copy.jpg';
            } else if (numPoints === 4) {
                siteData.mapImage = '/public/images/worthing-map-4-points-copy.jpg';
            } else {
                siteData.mapImage = '/public/images/worthing-map-3-points-copy.jpg';
            }
        }
        
        console.log(`Site ${siteNum} final data:`, {
            name: siteData.name,
            globalNumber: siteData.globalNumber,
            coordinates: siteData.coordinates,
            coordinateSystem: siteData.coordinateSystem
        });
        
        // If site already exists, update it in place; otherwise add a new site
        if (existingSite) {
            console.log(`Site ${siteNum} already exists, updating in place`);
            // Update the existing site in the batch
            const siteIndex = currentBatch.sites.findIndex(s => s.globalNumber === existingSite.globalNumber);
            if (siteIndex !== -1) {
                currentBatch.sites[siteIndex] = siteData;
            }
        } else {
            console.log(`Site ${siteNum} is new, adding to batch`);
            // Add the new site to the batch with the correct global number
            // Temporarily set the global counter to ensure the correct number is assigned
            const originalCounter = req.session.data['globalSiteCounter'];
            req.session.data['globalSiteCounter'] = siteNum - 1;
            addSiteToBatch(req.session, siteData);
            // Restore the original counter if it was higher
            if (originalCounter > req.session.data['globalSiteCounter']) {
                req.session.data['globalSiteCounter'] = originalCounter;
            }
        }
    }
    
    // Rebuild global sites array after batch operations
    if (req.session.data['siteBatches']) {
        req.session.data['sites'] = req.session.data['siteBatches'].flatMap(batch => batch.sites);
    }
    
    console.log('Final batch after conversion:', {
        id: currentBatch.id,
        sitesCount: currentBatch.sites.length,
        settings: currentBatch.settings,
        sites: currentBatch.sites.map(site => ({
            name: site.name,
            globalNumber: site.globalNumber,
            hasCoordinates: !!site.coordinates
        }))
    });
    console.log('=== END CONVERT MANUAL SITES TO UNIFIED FORMAT DEBUG ===');
}

// Function to add a single newly completed site to the current batch
function addCompletedSiteToCurrentBatch(session, batchRelativePosition) {
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch) {
        return false;
    }
    
    // Get site data from session first to check if we should proceed
    const siteNameKey = batchRelativePosition === 1 ? 'manual-site-name-text-input' : `manual-site-${batchRelativePosition}-name-text-input`;
    const siteName = session.data[siteNameKey];
    if (!siteName) {
        return false;
    }
    
    // Check if this site already exists in the batch by name (to avoid duplicates)
    const existingSiteByName = currentBatch.sites.find(site => site.name === siteName);
    if (existingSiteByName) {
        // Site already exists, don't add duplicate - just update it instead
        const entryMethodKey = batchRelativePosition === 1 ? 'manual-coordinate-entry-method' : `manual-site-${batchRelativePosition}-coordinate-entry-method`;
        const coordinateSystemKey = batchRelativePosition === 1 ? 'manual-coordinate-system-radios' : `manual-site-${batchRelativePosition}-coordinate-system-radios`;
        const sitePrefix = batchRelativePosition === 1 ? 'manual-' : `manual-site-${batchRelativePosition}-`;
        
        // Update coordinates based on entry method
        const entryMethod = session.data[entryMethodKey];
        if (entryMethod === 'Enter one set of coordinates and a width to create a circular site') {
            existingSiteByName.coordinates = {
                type: 'circle',
                center: {
                    latitude: session.data[`${sitePrefix}latitude`],
                    longitude: session.data[`${sitePrefix}longitude`]
                },
                width: session.data[`${sitePrefix}site-width`]
            };
        } else if (entryMethod === 'Enter multiple sets of coordinates to mark the boundary of the site') {
            existingSiteByName.coordinates = {
                type: 'polygon',
                points: []
            };
            // Add up to 5 points
            for (let i = 1; i <= 5; i++) {
                const lat = session.data[`${sitePrefix}coordinates-point-${i}-latitude`];
                const lng = session.data[`${sitePrefix}coordinates-point-${i}-longitude`];
                if (lat && lng) {
                    existingSiteByName.coordinates.points.push({
                        latitude: lat,
                        longitude: lng
                    });
                }
            }
        }
        
        // Update coordinate system
        existingSiteByName.coordinateSystem = session.data[coordinateSystemKey];
        
        // Update map image based on coordinate type
        if (existingSiteByName.coordinates && existingSiteByName.coordinates.type === 'circle') {
            existingSiteByName.mapImage = '/public/images/worthing-map-circle-copy.jpg';
        } else if (existingSiteByName.coordinates && existingSiteByName.coordinates.type === 'polygon') {
            const numPoints = existingSiteByName.coordinates.points.length;
            if (numPoints === 5) {
                existingSiteByName.mapImage = '/public/images/worthing-map-5-points-copy.jpg';
            } else if (numPoints === 4) {
                existingSiteByName.mapImage = '/public/images/worthing-map-4-points-copy.jpg';
            } else {
                existingSiteByName.mapImage = '/public/images/worthing-map-3-points-copy.jpg';
            }
        }
        
        // Rebuild global sites array
        session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
        
        return true;
    }
    
    // Check if this site already exists in the batch by batch position (alternative check)
    const existingSite = currentBatch.sites.find(site => {
        const existingBatchPos = getBatchRelativePosition(session, site.globalNumber);
        return existingBatchPos === batchRelativePosition;
    });
    
    if (existingSite) {
        // Site already exists, update it with new data instead of returning false
        const entryMethodKey = batchRelativePosition === 1 ? 'manual-coordinate-entry-method' : `manual-site-${batchRelativePosition}-coordinate-entry-method`;
        const coordinateSystemKey = batchRelativePosition === 1 ? 'manual-coordinate-system-radios' : `manual-site-${batchRelativePosition}-coordinate-system-radios`;
        const sitePrefix = batchRelativePosition === 1 ? 'manual-' : `manual-site-${batchRelativePosition}-`;
        
        // Update coordinates based on entry method
        const entryMethod = session.data[entryMethodKey];
        if (entryMethod === 'Enter one set of coordinates and a width to create a circular site') {
            existingSite.coordinates = {
                type: 'circle',
                center: {
                    latitude: session.data[`${sitePrefix}latitude`],
                    longitude: session.data[`${sitePrefix}longitude`]
                },
                width: session.data[`${sitePrefix}site-width`]
            };
        } else if (entryMethod === 'Enter multiple sets of coordinates to mark the boundary of the site') {
            existingSite.coordinates = {
                type: 'polygon',
                points: []
            };
            // Add up to 5 points
            for (let i = 1; i <= 5; i++) {
                const lat = session.data[`${sitePrefix}coordinates-point-${i}-latitude`];
                const lng = session.data[`${sitePrefix}coordinates-point-${i}-longitude`];
                if (lat && lng) {
                    existingSite.coordinates.points.push({
                        latitude: lat,
                        longitude: lng
                    });
                }
            }
        }
        
        // Update coordinate system
        existingSite.coordinateSystem = session.data[coordinateSystemKey];
        
        // Update map image based on coordinate type
        if (existingSite.coordinates && existingSite.coordinates.type === 'circle') {
            existingSite.mapImage = '/public/images/worthing-map-circle-copy.jpg';
        } else if (existingSite.coordinates && existingSite.coordinates.type === 'polygon') {
            const numPoints = existingSite.coordinates.points.length;
            if (numPoints === 5) {
                existingSite.mapImage = '/public/images/worthing-map-5-points-copy.jpg';
            } else if (numPoints === 4) {
                existingSite.mapImage = '/public/images/worthing-map-4-points-copy.jpg';
            } else {
                existingSite.mapImage = '/public/images/worthing-map-3-points-copy.jpg';
            }
        }
        
        // Rebuild global sites array
        session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
        
        return true;
    }

    // Create site data object for new site
    const siteData = {
        name: siteName,
        startDate: {},
        endDate: {},
        description: ''
    };
    
    // Handle dates - either shared or individual
    if (session.data['manual-same-activity-dates'] === 'Yes') {
        // Use shared dates
        siteData.startDate = {
            day: session.data['manual-start-date-date-input-day'],
            month: session.data['manual-start-date-date-input-month'],
            year: session.data['manual-start-date-date-input-year']
        };
        siteData.endDate = {
            day: session.data['manual-end-date-date-input-day'],
            month: session.data['manual-end-date-date-input-month'],
            year: session.data['manual-end-date-date-input-year']
        };
    } else {
        // Use site-specific dates
        const startDatePrefix = batchRelativePosition === 1 ? 'manual-' : `manual-site-${batchRelativePosition}-`;
        siteData.startDate = {
            day: session.data[`${startDatePrefix}start-date-date-input-day`],
            month: session.data[`${startDatePrefix}start-date-date-input-month`],
            year: session.data[`${startDatePrefix}start-date-date-input-year`]
        };
        siteData.endDate = {
            day: session.data[`${startDatePrefix}end-date-date-input-day`],
            month: session.data[`${startDatePrefix}end-date-date-input-month`],
            year: session.data[`${startDatePrefix}end-date-date-input-year`]
        };
    }
    
    // Handle description - either shared or individual
    if (session.data['manual-same-activity-description'] === 'Yes') {
        siteData.description = session.data['manual-activity-details-text-area'];
    } else {
        const descriptionKey = batchRelativePosition === 1 ? 'manual-activity-details-text-area' : `manual-site-${batchRelativePosition}-activity-details-text-area`;
        siteData.description = session.data[descriptionKey];
    }
    
    // Add coordinates based on entry method
    const entryMethodKey = batchRelativePosition === 1 ? 'manual-coordinate-entry-method' : `manual-site-${batchRelativePosition}-coordinate-entry-method`;
    const coordinateSystemKey = batchRelativePosition === 1 ? 'manual-coordinate-system-radios' : `manual-site-${batchRelativePosition}-coordinate-system-radios`;
    const sitePrefix = batchRelativePosition === 1 ? 'manual-' : `manual-site-${batchRelativePosition}-`;
    
    const entryMethod = session.data[entryMethodKey];
    if (entryMethod === 'Enter one set of coordinates and a width to create a circular site') {
        siteData.coordinates = {
            type: 'circle',
            center: {
                latitude: session.data[`${sitePrefix}latitude`],
                longitude: session.data[`${sitePrefix}longitude`]
            },
            width: session.data[`${sitePrefix}site-width`]
        };
    } else if (entryMethod === 'Enter multiple sets of coordinates to mark the boundary of the site') {
        siteData.coordinates = {
            type: 'polygon',
            points: []
        };
        // Add up to 5 points
        for (let i = 1; i <= 5; i++) {
            const lat = session.data[`${sitePrefix}coordinates-point-${i}-latitude`];
            const lng = session.data[`${sitePrefix}coordinates-point-${i}-longitude`];
            if (lat && lng) {
                siteData.coordinates.points.push({
                    latitude: lat,
                    longitude: lng
                });
            }
        }
    }
    
    // Add coordinate system
    siteData.coordinateSystem = session.data[coordinateSystemKey];
    
    // Add map image based on coordinate type
    if (siteData.coordinates && siteData.coordinates.type === 'circle') {
        siteData.mapImage = '/public/images/worthing-map-circle-copy.jpg';
    } else if (siteData.coordinates && siteData.coordinates.type === 'polygon') {
        const numPoints = siteData.coordinates.points.length;
        if (numPoints === 5) {
            siteData.mapImage = '/public/images/worthing-map-5-points-copy.jpg';
        } else if (numPoints === 4) {
            siteData.mapImage = '/public/images/worthing-map-4-points-copy.jpg';
        } else {
            siteData.mapImage = '/public/images/worthing-map-3-points-copy.jpg';
        }
    }
    
    // Add the site to the batch using existing function which assigns global number
    return addSiteToBatch(session, siteData);
}

// ===== MIGRATED: Add next site - GET route =====
router.get('/' + version + section + 'manual-entry/add-next-site-router', function (req, res) {
    // Get next global site number
    const nextGlobalSiteNumber = (req.session.data['globalSiteCounter'] || 0) + 1;
    
    // Clear any stale session parameters
    delete req.session.data['returnTo'];
    delete req.session.data['fromReviewSiteDetails'];
    delete req.session.data['currentManualEntrySiteId'];
    
    // Clear session data that might contaminate the new site
    clearCurrentSiteSessionData(req.session);
    
    console.log(`Starting new site ${nextGlobalSiteNumber} - session cleared`);
    
    // Redirect to site name page for the new site
    res.redirect('site-name?site=' + nextGlobalSiteNumber);
});

// Enter multiple coordinates - POST route
router.post('/' + version + section + 'manual-entry/enter-multiple-coordinates-router', function (req, res) {
    // Reset global error states
    req.session.data['errorthispage'] = "false";
    req.session.data['errors'] = [];

    const siteNumber = parseInt(req.query.site || req.session.data['current-site'] || 1);
    const returnTo = req.query.returnTo || req.session.data['returnTo'];

    // Determine if we're editing an existing site or creating a new one
    const isEditingExistingSite = returnTo === 'review-site-details' && findSiteByGlobalNumber(req.session, siteNumber) !== undefined;
    
    let batchRelativePosition;
    let sitePrefix;
    let systemKey;
    
    if (isEditingExistingSite) {
        // We're editing an existing site - use global site number for session keys
        batchRelativePosition = getBatchRelativePosition(req.session, siteNumber);
        sitePrefix = siteNumber === 1 ? 'manual-' : `manual-site-${siteNumber}-`;
        systemKey = siteNumber === 1 ? 'manual-coordinate-system-radios' : `manual-site-${siteNumber}-coordinate-system-radios`;
    } else {
        // We're creating a new site - siteNumber is a batch-relative number
        batchRelativePosition = siteNumber;
        sitePrefix = batchRelativePosition === 1 ? 'manual-' : `manual-site-${batchRelativePosition}-`;
        systemKey = batchRelativePosition === 1 ? 'manual-coordinate-system-radios' : `manual-site-${batchRelativePosition}-coordinate-system-radios`;
    }
    
    // Get the selected coordinate system
    const system = req.session.data[systemKey];
    const usingOSGB36 = system === "OSGB36 (National Grid)";
    const latLabel = usingOSGB36 ? "Eastings" : "Latitude";
    const longLabel = usingOSGB36 ? "Northings" : "Longitude";

    // Loop over points 1-5
    for (let i = 1; i <= 5; i++) {
        const latKey = sitePrefix + `coordinates-point-${i}-latitude`;
        const longKey = sitePrefix + `coordinates-point-${i}-longitude`;
        const latVal = req.session.data[latKey];
        const longVal = req.session.data[longKey];

        const latMissing = !latVal || latVal.trim() === "";
        const longMissing = !longVal || longVal.trim() === "";

        const pointLabel = i === 1 ? "start and end point" : `point ${i}`;

        // Check visibility for Points 4 & 5 based on flags
        const visibilityKey = sitePrefix + `coordinates-visible-point-${i}`;
        const isPointVisible = i <= 3 || req.session.data[visibilityKey] === "true";

        // Skip validation for hidden points with no entered data
        if (!isPointVisible && (latMissing && longMissing)) {
            req.session.data[`error-${latKey}`] = "false";
            req.session.data[`error-${longKey}`] = "false";
            continue;
        }

        // If lat or long is missing, mark as an error
        if (latMissing || longMissing) {
            req.session.data['errorthispage'] = "true";
        }

        // Latitude error handling
        if (latMissing) {
            req.session.data[`error-${latKey}`] = "true";
            req.session.data['errors'].push({
                text: `Enter the ${latLabel.toLowerCase()} of ${pointLabel}`,
                anchor: `${latKey}`
            });
        } else {
            req.session.data[`error-${latKey}`] = "false";
        }

        // Longitude error handling
        if (longMissing) {
            req.session.data[`error-${longKey}`] = "true";
            req.session.data['errors'].push({
                text: `Enter the ${longLabel.toLowerCase()} of ${pointLabel}`,
                anchor: `${longKey}`
            });
        } else {
            req.session.data[`error-${longKey}`] = "false";
        }
    }

    // Copy manual coordinates to the coordinates data structure for display
    for (let i = 1; i <= 5; i++) {
        const manualLat = req.session.data[sitePrefix + `coordinates-point-${i}-latitude`];
        const manualLong = req.session.data[sitePrefix + `coordinates-point-${i}-longitude`];
        
        if (manualLat) {
            req.session.data[sitePrefix + `coordinates-point-${i}-latitude`] = manualLat;
        }
        if (manualLong) {
            req.session.data[sitePrefix + `coordinates-point-${i}-longitude`] = manualLong;
        }
    }

    // Redirect to the current page if there are errors, else continue to the next page
    if (req.session.data['errorthispage'] === "true") {
        const redirectUrl = 'enter-multiple-coordinates' + (siteNumber > 1 ? '?site=' + siteNumber : '') + (returnTo ? (siteNumber > 1 ? '&' : '?') + 'returnTo=' + returnTo : '');
        return res.redirect(redirectUrl);
    }

    // If we're editing an existing site, update the unified format and return to review
    if (isEditingExistingSite) {
        // Update the existing site in the unified format with the new data
        addCompletedSiteToCurrentBatch(req.session, batchRelativePosition);
        
        // Clear return flags and return directly to review
        delete req.session.data['fromReviewSiteDetails'];
        delete req.session.data['returnTo'];
        return res.redirect('review-site-details#site-' + siteNumber + '-details');
    }

    // If we're creating a new site, we need to convert it to unified format now
    // Convert manual sites to unified format to pick up the newly completed site
    addCompletedSiteToCurrentBatch(req.session, batchRelativePosition);

    // Redirect to review page
    res.redirect('review-site-details');
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Cancel actions for manual entry
// These redirect to the main cancel handlers in the parent exemption routes
/////////////////////////////////////////////////////////////////////////////////////////////

router.get('/' + version + section + 'manual-entry/cancel-site-details', function (req, res) {
    // Redirect to the main cancel handler
    res.redirect('../cancel-site-details');
});

router.get('/' + version + section + 'manual-entry/cancel-to-review', function (req, res) {
    // Redirect to the main cancel handler
    res.redirect('../cancel-to-review');
});

router.get('/' + version + section + 'manual-entry/cancel-from-review-site-details', function (req, res) {
    // Redirect to the main cancel handler
    res.redirect('../cancel-from-review-site-details');
});

}