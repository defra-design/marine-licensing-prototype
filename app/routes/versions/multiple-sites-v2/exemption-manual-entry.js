// Generated by Copilot

const path = require('path');

// LEGACY CODE REMOVED: renumberManualEntrySessionData function
// This was replaced by the unified model's renumberUnifiedSitesAfterDeletion function

// Import unified model functions from exemption.js
const exemptionModule = require('./exemption.js');

// TEMPORARY: Backward compatibility function
function ensureUnifiedModelCompatibility(session) {
    // If using old session-based approach, migrate to unified model
    if (!session.data['unifiedSites'] && session.data['manual-site-name-text-input']) {
        console.log('Migrating legacy session data to unified model');
        migrateToUnifiedModel(session);
        
        // Create site from legacy session data
        const site = createNewSite(session);
        site.name = session.data['manual-site-name-text-input'] || '';
        
        // Clear legacy session keys
        Object.keys(session.data).forEach(key => {
            if (key.startsWith('manual-site-')) {
                delete session.data[key];
            }
        });
        
        session.data['currentManualEntrySiteId'] = site.id;
    }
}

module.exports = function (router) {
    let version = "versions/multiple-sites-v2/";
    let section = "exemption/";

//////////////////////////////////////////////////////////////////////////////////////////////
// Manual Entry Flow Routes
//////////////////////////////////////////////////////////////////////////////////////////////
// Batch handling functions
function initializeBatch(session, entryMethod) {
    const batchId = Date.now().toString(); // Unique batch ID
    const batch = {
        id: batchId,
        entryMethod: entryMethod,
        createdAt: new Date().toISOString(),
        sites: [],
        startingGlobalNumber: session.data['globalSiteCounter'] || 0  // Store the starting position
    };
    if (!session.data['siteBatches']) {
        session.data['siteBatches'] = [];
    }
    session.data['siteBatches'].push(batch);
    session.data['currentBatchId'] = batchId;
    return batchId;
}

function getCurrentBatch(session) {
    const batchId = session.data['currentBatchId'];
    if (!batchId || !session.data['siteBatches']) {
        return null;
    }
    return session.data['siteBatches'].find(batch => batch.id === batchId);
}

function addSiteToBatch(session, siteData) {
    const batch = getCurrentBatch(session);
    if (!batch) {
        return false;
    }
    
    // Initialize global site counter if it doesn't exist
    if (!session.data['globalSiteCounter']) {
        session.data['globalSiteCounter'] = 0;
    }
    
    // Assign global site number
    session.data['globalSiteCounter']++;
    siteData.globalNumber = session.data['globalSiteCounter'];
    
    siteData.batchId = batch.id;
    siteData.entryMethod = batch.entryMethod;
    siteData.addedAt = new Date().toISOString();
    batch.sites.push(siteData);
    // Rebuild global sites array from all batches to prevent duplicates
    if (!session.data['siteBatches']) {
        session.data['sites'] = [];
    } else {
        session.data['sites'] = session.data['siteBatches'].flatMap(batch => batch.sites);
    }
    return true;
}

function getSitesByBatch(session, batchId) {
    if (!session.data['siteBatches']) {
        return [];
    }
    const batch = session.data['siteBatches'].find(b => b.id === batchId);
    return batch ? batch.sites : [];
}

function getAllSites(session) {
    if (!session.data['siteBatches']) {
        return [];
    }
    return session.data['siteBatches'].flatMap(batch => batch.sites);
}

// Helper function to find a site by global number
function findSiteByGlobalNumber(session, globalNumber) {
    const allSites = getAllSites(session);
    return allSites.find(site => site.globalNumber === parseInt(globalNumber));
}

// Helper function to get the batch-relative position of a site by global number
function getBatchRelativePosition(session, globalNumber) {
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch || !currentBatch.sites) {
        return 1;
    }
    
    const siteIndex = currentBatch.sites.findIndex(site => site.globalNumber === parseInt(globalNumber));
    return siteIndex !== -1 ? siteIndex + 1 : 1;
}

// Function to clear manual entry session data for a fresh batch start
function clearManualEntrySessionData(session, startingSiteNumber) {
    // Clear batch-level settings
    delete session.data['manual-same-activity-dates'];
    delete session.data['manual-same-activity-description'];
    
    // Clear shared activity dates
    delete session.data['manual-start-date-date-input-day'];
    delete session.data['manual-start-date-date-input-month'];
    delete session.data['manual-start-date-date-input-year'];
    delete session.data['manual-end-date-date-input-day'];
    delete session.data['manual-end-date-date-input-month'];
    delete session.data['manual-end-date-date-input-year'];
    
    // Clear shared activity description
    delete session.data['manual-activity-details-text-area'];
    
    // Clear all possible site-specific data (for a wide range of potential site numbers)
    for (let siteNum = 1; siteNum <= 20; siteNum++) {
        // Site names
        if (siteNum === 1) {
            delete session.data['manual-site-name-text-input'];
        } else {
            delete session.data[`manual-site-${siteNum}-name-text-input`];
        }
        
        // Site-specific dates
        const sitePrefix = siteNum === 1 ? 'manual-' : `manual-site-${siteNum}-`;
        delete session.data[`${sitePrefix}start-date-date-input-day`];
        delete session.data[`${sitePrefix}start-date-date-input-month`];
        delete session.data[`${sitePrefix}start-date-date-input-year`];
        delete session.data[`${sitePrefix}end-date-date-input-day`];
        delete session.data[`${sitePrefix}end-date-date-input-month`];
        delete session.data[`${sitePrefix}end-date-date-input-year`];
        
        // Site-specific descriptions
        if (siteNum === 1) {
            // Note: shared description uses 'manual-activity-details-text-area', already cleared above
        } else {
            delete session.data[`manual-site-${siteNum}-activity-details-text-area`];
        }
        
        // Coordinate entry methods and systems
        delete session.data[`${sitePrefix}coordinate-entry-method`];
        delete session.data[`${sitePrefix}coordinate-system-radios`];
        
        // Coordinate data
        delete session.data[`${sitePrefix}latitude`];
        delete session.data[`${sitePrefix}longitude`];
        delete session.data[`${sitePrefix}site-width`];
        
        // Multiple coordinates
        for (let i = 1; i <= 5; i++) {
            delete session.data[`${sitePrefix}coordinates-point-${i}-latitude`];
            delete session.data[`${sitePrefix}coordinates-point-${i}-longitude`];
        }
    }
    
    // Clear any error states
    delete session.data['errorthispage'];
    delete session.data['errortypeone'];
    delete session.data['errortypetwo'];
    delete session.data['startdateerror'];
    delete session.data['enddateerror'];
    delete session.data['errors'];
}

// LEGACY CODE REMOVED: populateSessionDataFromSite function
// This was replaced by the unified model's site object approach - sites maintain their own data

// NEW: Initialize new sites with inherited data from batch settings
function initializeNewSiteWithInheritedData(session, newSite) {
    console.log(`=== INITIALIZING SITE ${newSite.globalNumber} WITH INHERITED DATA ===`);
    
    const currentBatch = getCurrentBatch(session);
    if (!currentBatch || !currentBatch.settings) {
        console.log('No batch settings found for data inheritance');
        return;
    }
    
    // Apply same activity dates if they exist
    if (currentBatch.settings.sameActivityDates === 'Yes' && currentBatch.settings.sharedStartDate) {
        newSite.startDate = { ...currentBatch.settings.sharedStartDate };
        newSite.endDate = { ...currentBatch.settings.sharedEndDate };
        console.log(`Inherited shared activity dates for site ${newSite.globalNumber}`);
    }
    
    // Apply same activity description if it exists
    if (currentBatch.settings.sameActivityDescription === 'Yes' && currentBatch.settings.sharedDescription) {
        newSite.description = currentBatch.settings.sharedDescription;
        console.log(`Inherited shared activity description for site ${newSite.globalNumber}`);
    }
    
    console.log(`=== INHERITANCE COMPLETE FOR SITE ${newSite.globalNumber} ===`);
}

// Helper function to clear session data that might contaminate between sites
function clearCurrentSiteSessionData(session) {
    console.log('=== CLEARING CURRENT SITE SESSION DATA ===');
    
    // Clear session data that might persist between sites
    const keysToClear = [
        'manual-site-name-text-input',
        'coordinates-latitude',
        'coordinates-longitude',
        'activity-details-text-area',
        'site-width',
        'coordinate-format',
        'manual-coordinate-entry-method',
        'manual-coordinate-system-radios'
    ];
    
    let clearedCount = 0;
    keysToClear.forEach(key => {
        if (session.data[key]) {
            delete session.data[key];
            clearedCount++;
            console.log(`Cleared session key: ${key}`);
        }
    });
    
    console.log(`=== CLEARED ${clearedCount} SESSION KEYS ===`);
}

// ==============================================================================================
// CANCEL FUNCTIONALITY - STATE DETECTION SYSTEM (copied from exemption.js)
// ==============================================================================================

/**
 * Tracks review page state changes
 * @param {Object} session - Express session object
 * @param {String} action - 'visited' | 'saved' | 'editing'
 */
function updateReviewState(session, action) {
    console.log('üìù Manual Entry - Updating Review State:', action);
    
    switch(action) {
        case 'visited':
            session.data['reviewPageVisited'] = true;
            // Don't change saved or editing state when just visiting
            break;
            
        case 'saved':
            session.data['reviewPageVisited'] = true;
            session.data['reviewPageSaved'] = true;
            session.data['isEditingFromReview'] = false; // Clear editing state after save
            break;
            
        case 'editing':
            // User clicked change link from review page
            session.data['reviewPageVisited'] = true;
            session.data['isEditingFromReview'] = true;
            // Don't change saved state - preserve existing value
            break;
    }
}

/**
 * Sets the origin context when user enters the flow
 * @param {Object} session - Express session object
 * @param {String} origin - Origin identifier
 */
function setOriginContext(session, origin) {
    console.log('üìç Manual Entry - Setting Origin Context:', origin);
    session.data['cancelOrigin'] = origin;
    
    // Clear any conflicting navigation flags when setting new origin
    if (origin === 'task-list') {
        delete session.data['camefromcheckanswers'];
        delete session.data['fromReviewSiteDetails'];
    }
}

/**
 * Comprehensive state logging for debugging
 * @param {Object} session - Express session object
 * @param {String} context - Current page/action context
 */
function logCancelState(session, context) {
    if (process.env.NODE_ENV !== 'production') { // Only log in development
        console.log('üö® ============== MANUAL ENTRY CANCEL STATE DEBUG ==============');
        console.log('üìç Context:', context);
        console.log('üéØ Current State Flags:');
        console.log('   - cancelOrigin:', session.data['cancelOrigin']);
        console.log('   - reviewPageVisited:', session.data['reviewPageVisited']);
        console.log('   - reviewPageSaved:', session.data['reviewPageSaved']);
        console.log('   - isEditingFromReview:', session.data['isEditingFromReview']);
        console.log('   - currentBatchId:', session.data['currentBatchId']);
        
        console.log('üèóÔ∏è  Legacy Flags (for transition):');
        console.log('   - fromReviewSiteDetails:', session.data['fromReviewSiteDetails']);
        console.log('   - siteDetailsSaved:', session.data['siteDetailsSaved']);
        console.log('   - camefromcheckanswers:', session.data['camefromcheckanswers']);
        console.log('   - returnTo:', session.data['returnTo']);
        
        console.log('üìä Batch Information:');
        const currentBatch = getCurrentBatch(session);
        if (currentBatch) {
            console.log('   - Current Batch ID:', currentBatch.id);
            console.log('   - Entry Method:', currentBatch.entryMethod);
            console.log('   - Site Count:', currentBatch.sites ? currentBatch.sites.length : 0);
        } else {
            console.log('   - No current batch');
        }
        
        console.log('üö® ========================================================');
    }
}

// ===== MIGRATED: Does your project involve more than one site? - GET route =====
router.get('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site', function (req, res) {
    // Set origin context if starting new journey (usually from task list)
    if (!req.session.data['cancelOrigin']) {
        setOriginContext(req.session, 'task-list');
    }
    
    // Initialize review state for new manual entry journey
    req.session.data['reviewPageVisited'] = false;
    req.session.data['reviewPageSaved'] = false;
    req.session.data['isEditingFromReview'] = false;
    
    logCancelState(req.session, 'manual entry - does-your-project-involve-more-than-one-site GET');
    
    res.render(version + section + 'manual-entry/does-your-project-involve-more-than-one-site', {
        data: req.session.data,
        errors: {}
    });
});

// ===== MIGRATED: Does your project involve more than one site? - POST route =====
router.post('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site-router', function (req, res) {
    const selection = req.body['manual-multiple-sites'];

    if (!selection) {
        return res.render(version + section + 'manual-entry/does-your-project-involve-more-than-one-site', {
            data: req.session.data,
            errors: { 'multipleSites': 'Please select whether your project involves more than one site' }
        });
    }

    // Initialize a new batch for this manual entry session
    const batchId = initializeBatch(req.session, 'manual-entry');
    req.session.data['currentBatchId'] = batchId;
    
    // Clear any previous manual entry session data
    clearManualEntrySessionData(req.session, 1);

    // Route based on selection
    const nextGlobalSiteNumber = (req.session.data['globalSiteCounter'] || 0) + 1;
    
    if (selection === 'No') {
        // Single site flow: Create site without name and skip to activity dates
        console.log('üîÄ Single site flow: Creating site without name and going to activity dates');
        
        // Create minimal site object without name for single site journey
        const site = {
            name: '', // Empty name for single sites - not displayed or required
            startDate: { day: '', month: '', year: '' },
            endDate: { day: '', month: '', year: '' },
            description: '',
            coordinates: {}
        };
        
        addSiteToBatch(req.session, site);
        console.log(`‚úÖ Created single site in batch: global number ${site.globalNumber}`);
        
        // Go directly to individual activity dates, skipping site name
        res.redirect('individual-site-activity-dates?site=' + site.globalNumber);
    } else {
        // Multiple site flow: go to site-name as before
        console.log('üîÄ Multiple site flow: Going to site name page');
        res.redirect('site-name?site=' + nextGlobalSiteNumber);
    }
});

// CONVERTED: Batch system approach for site name GET route
router.get('/' + version + section + 'manual-entry/site-name', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    console.log(`=== SITE NAME GET DEBUG ===`);
    console.log(`Site parameter: ${siteParam}`);
    console.log(`Return to: ${returnTo}`);
    
    let site = null;
    let isEditing = false;
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found, redirecting to start');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    if (siteParam && returnTo === 'review-site-details') {
        // EDITING MODE: Find existing site in batch
        console.log(`üîÑ EDITING MODE: Looking for site ${siteParam} in batch`);
        site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
        isEditing = !!site;
        
        // Track that user is editing from review page
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - site-name GET - editing from review');
        
        if (!site) {
            console.log(`‚ùå ERROR: Site ${siteParam} not found in batch for editing`);
            // Redirect back to review if site not found
            return res.redirect('/' + version + section + 'manual-entry/review-site-details');
        }
        
        console.log(`‚úÖ Found existing site for editing: "${site.name}"`);
    } else {
        // CREATE MODE: Create new site structure for form
        console.log(`‚ûï CREATE MODE: Creating new site structure`);
        const globalNumber = (req.session.data['globalSiteCounter'] || 0) + 1;
        site = {
            name: '',
            startDate: { day: '', month: '', year: '' },
            endDate: { day: '', month: '', year: '' },
            description: '',
            coordinates: {},
            globalNumber: globalNumber,
            validationErrors: {}
        };
        
        // SPECIAL CASE: If this is a subsequent site (batch already has sites), 
        // treat as "creation-review" so cancel returns to review page
        if (currentBatch && currentBatch.sites && currentBatch.sites.length > 0) {
            console.log(`üîÑ SUBSEQUENT SITE: Site ${globalNumber} - setting creation-review state`);
            updateReviewState(req.session, 'editing');
            logCancelState(req.session, 'manual entry - site-name GET - subsequent site creation (will return to review on cancel)');
        }
        
        // Auto-populate shared data if this isn't the first site
        if (site.globalNumber > 1) {
            initializeNewSiteWithInheritedData(req.session, site);
        }
    }
    
    res.render(path.join(version, section, 'manual-entry', 'site-name'), {
        data: req.session.data,
        site: site,
        isEditing: isEditing,
        returnTo: returnTo,
        errors: site.validationErrors || {}
    });
});

// CONVERTED: Batch system POST handler for site name
router.post('/' + version + section + 'manual-entry/site-name-router', function (req, res) {
    const siteName = req.body['site-name'];
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    console.log(`=== SITE NAME ROUTER DEBUG ===`);
    console.log(`Site name: "${siteName}"`);
    console.log(`Site parameter: ${siteParam}`);
    console.log(`Return to: ${returnTo}`);
    console.log(`Query string: ${req.originalUrl}`);
    
    // Validation
    if (!siteName || siteName.trim() === '') {
        const site = { 
            globalNumber: siteParam,
            name: '',
            validationErrors: { name: 'Enter a site name' }
        };
        return res.render(path.join(version, section, 'manual-entry', 'site-name'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            returnTo: returnTo,
            errors: site.validationErrors
        });
    }
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    console.log(`Current batch has ${currentBatch.sites.length} sites`);
    
    let site;
    
    // SIMPLIFIED LOGIC: If returnTo=review-site-details, we're ALWAYS editing an existing site
    if (returnTo === 'review-site-details') {
        console.log(`üîÑ EDITING MODE: Looking for existing site ${siteParam} in batch`);
        
        // Find the existing site in batch
        site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
        
        if (!site) {
            console.log(`‚ùå ERROR: Site ${siteParam} not found in batch when editing from review page!`);
            console.log(`Available sites:`, currentBatch.sites.map(s => s.globalNumber));
            // This shouldn't happen - redirect back to review to avoid errors
            return res.redirect('/' + version + section + 'manual-entry/review-site-details');
        }
        
        // Update the existing site's name
        site.name = siteName.trim();
        console.log(`‚úÖ Updated existing site ${site.globalNumber} name to: "${site.name}"`);
        
        // DIRECT RETURN to review page with anchor - no further flow
        console.log(`üîÑ DIRECT RETURN: Redirecting back to review page with anchor`);
        return res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
        
    } else {
        console.log(`‚ûï CREATE MODE: Adding new site to batch`);
        
        // Creating new site - add to batch
        site = {
            name: siteName.trim(),
            startDate: { day: '', month: '', year: '' },
            endDate: { day: '', month: '', year: '' },
            description: '',
            coordinates: {}
        };
        
        addSiteToBatch(req.session, site);
        console.log(`‚úÖ Added new site to batch: "${site.name}", global number: ${site.globalNumber}`);
        
        // CONTINUE FLOW for new site creation
        const multiSiteChoice = req.session.data['manual-multiple-sites'];
        console.log(`üß≠ Navigation: Site name complete for new site ${site.globalNumber}, multiSiteChoice: ${multiSiteChoice}`);
        
        if (multiSiteChoice === 'No') {
            // Single site flow: go to individual activity dates
            console.log(`üîÄ Navigation: Single site flow ‚Üí individual-site-activity-dates`);
            return res.redirect('/' + version + section + 'manual-entry/individual-site-activity-dates?site=' + site.globalNumber);
        } else {
            // Multiple site flow: check if this is the first site or subsequent site
            const hasSharedActivityDatesAnswer = currentBatch && 
                currentBatch.settings && 
                currentBatch.settings.sameActivityDates;
            
            console.log(`üîÄ Navigation: Multiple site flow, hasSharedActivityDatesAnswer: ${hasSharedActivityDatesAnswer}`);
            
            if (!hasSharedActivityDatesAnswer) {
                // First site: ask about shared activity dates
                console.log(`üîÄ Navigation: First site ‚Üí same-activity-dates`);
                return res.redirect('/' + version + section + 'manual-entry/same-activity-dates');
            } else {
                // Subsequent site: route based on previous choices
                if (currentBatch.settings.sameActivityDates === 'Yes') {
                    // Shared dates chosen: skip dates, check descriptions
                    if (!currentBatch.settings.sameActivityDescription) {
                        // Need to ask about shared descriptions first
                        console.log(`üîÄ Navigation: Subsequent site, shared dates ‚Üí same-activity-description`);
                        return res.redirect('/' + version + section + 'manual-entry/same-activity-description');
                    } else if (currentBatch.settings.sameActivityDescription === 'Yes') {
                        // Both shared: skip to coordinates
                        console.log(`üîÄ Navigation: Subsequent site, both shared ‚Üí coordinates`);
                        return res.redirect('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates?site=' + site.globalNumber);
                    } else {
                        // Shared dates, individual descriptions
                        console.log(`üîÄ Navigation: Subsequent site, shared dates, individual descriptions ‚Üí individual-site-activity-description`);
                        return res.redirect('/' + version + section + 'manual-entry/individual-site-activity-description?site=' + site.globalNumber);
                    }
                } else {
                    // Individual dates chosen: go to individual dates for this site
                    console.log(`üîÄ Navigation: Subsequent site, individual dates ‚Üí individual-site-activity-dates`);
                    return res.redirect('/' + version + section + 'manual-entry/individual-site-activity-dates?site=' + site.globalNumber);
                }
            }
        }
    }
});

// ===== MIGRATED: same-activity-dates routes to unified model =====

// Are the activity dates the same for every site? - GET route
router.get('/' + version + section + 'manual-entry/same-activity-dates', function (req, res) {
    
    const returnTo = req.query.returnTo;
    
    // Get or create current batch for flow control data
    let currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        currentBatch = initializeBatch(req.session, 'manual-entry');
    }
    
    res.render(version + section + 'manual-entry/same-activity-dates', {
        data: req.session.data,
        currentBatch: currentBatch,
        returnTo: returnTo,
        errors: {}
    });
});

// Are the activity dates the same for every site? - POST route
router.post('/' + version + section + 'manual-entry/same-activity-dates-router', function (req, res) {
    const selection = req.body['manual-same-activity-dates'];
    const returnTo = req.query.returnTo;

    if (!selection) {
        const currentBatch = getCurrentBatch(req.session);
        return res.render(version + section + 'manual-entry/same-activity-dates', {
            data: req.session.data,
            currentBatch: currentBatch,
            returnTo: returnTo,
            errors: { 'sameActivityDates': 'Please select an option' }
        });
    }

    // Get current batch and store previous selection before updating
    const currentBatch = getCurrentBatch(req.session);
    const previousSelection = currentBatch && currentBatch.settings ? currentBatch.settings.sameActivityDates : null;
    
    // Store the new selection in batch settings
    if (currentBatch) {
        if (!currentBatch.settings) {
            currentBatch.settings = {};
        }
        currentBatch.settings.sameActivityDates = selection;
    }

    // If returning from review, handle shared date updates
    if (returnTo === 'review-site-details') {
        // If changing from Yes to No, copy shared dates to individual sites
        if (selection === "No" && previousSelection === "Yes") {
            // Copy shared dates to all batch sites
            const sharedStartDate = currentBatch.settings.sharedStartDate;
            const sharedEndDate = currentBatch.settings.sharedEndDate;
            
            if (sharedStartDate && sharedStartDate.day && currentBatch.sites) {
                currentBatch.sites.forEach(site => {
                    site.startDate = { ...sharedStartDate };
                    site.endDate = { ...sharedEndDate };
                });
            }
            
            // Clear shared dates from batch settings after copying
            currentBatch.settings.sharedStartDate = {};
            currentBatch.settings.sharedEndDate = {};
        }
        // If changing from No to Yes, use first site's data as shared data
        else if (selection === "Yes" && previousSelection === "No") {
            // Use first site's dates as shared dates
            if (currentBatch.sites && currentBatch.sites.length > 0) {
                const firstSite = currentBatch.sites[0];
                if (firstSite.startDate && firstSite.startDate.day) {
                    currentBatch.settings.sharedStartDate = { ...firstSite.startDate };
                    currentBatch.settings.sharedEndDate = { ...firstSite.endDate };
                    
                    // Apply shared dates to all sites
                    currentBatch.sites.forEach(site => {
                        site.startDate = { ...currentBatch.settings.sharedStartDate };
                        site.endDate = { ...currentBatch.settings.sharedEndDate };
                    });
                }
            }
        }
        
        return res.redirect('/' + version + section + 'manual-entry/review-site-details');
    }

    // Route based on selection - use first site from batch
    const siteNumber = currentBatch.sites.length > 0 ? currentBatch.sites[0].globalNumber : 1;
    
    switch(selection) {
        case "Yes":
            res.redirect('activity-dates?site=' + siteNumber);
            break;
        case "No":
            res.redirect('individual-site-activity-dates?site=' + siteNumber);
            break;
        default:
            res.redirect('same-activity-dates?site=' + siteNumber);
    }
});

// CONVERTED: Batch system individual site activity dates GET route
router.get('/' + version + section + 'manual-entry/individual-site-activity-dates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for individual activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for individual activity dates');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - individual-site-activity-dates GET - editing from review');
    }
    
    // SPECIAL CASE: If this is a subsequent site being created (not editing from review), 
    // set creation-review state so cancel returns to review page
    if (returnTo !== 'review-site-details' && parseInt(siteParam) > 1) {
        console.log(`üîÑ SUBSEQUENT SITE: Activity dates for site ${siteParam} - setting creation-review state`);
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - individual-site-activity-dates GET - subsequent site creation');
    }
    
    res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-dates'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: site.validationErrors || {}
    });
});

// NEW: Unified model individual site activity dates POST route
router.post('/' + version + section + 'manual-entry/individual-site-activity-dates-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== INDIVIDUAL ACTIVITY DATES FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const startDay = req.body['start-date-date-input-day'];
    const startMonth = req.body['start-date-date-input-month'];
    const startYear = req.body['start-date-date-input-year'];
    
    const endDay = req.body['end-date-date-input-day'];
    const endMonth = req.body['end-date-date-input-month'];
    const endYear = req.body['end-date-date-input-year'];
    
    console.log(`Processing individual activity dates for site: ${siteParam}`);
    console.log(`Extracted dates - Start: ${startDay}/${startMonth}/${startYear}, End: ${endDay}/${endMonth}/${endYear}`);
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for individual activity dates update');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Update activity dates directly in batch site
    site.startDate = {
        day: startDay || '',
        month: startMonth || '',
        year: startYear || ''
    };
    site.endDate = {
        day: endDay || '',
        month: endMonth || '',
        year: endYear || ''
    };
    
    // Basic validation
    let isValid = true;
    if (!startDay || !startMonth || !startYear || !endDay || !endMonth || !endYear) {
        isValid = false;
        site.validationErrors = { ...site.validationErrors, dates: 'Enter complete start and end dates' };
    } else {
        // Clear date errors if validation passes
        if (site.validationErrors) {
            delete site.validationErrors.dates;
            delete site.validationErrors.startDate;
            delete site.validationErrors.endDate;
        }
    }
    
    if (!isValid) {
        console.log('Individual activity dates validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-dates'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            returnTo: returnTo,
            errors: site.validationErrors
        });
    }
    
    // Clear date-related errors
    ['startDate', 'endDate'].forEach(field => {
        if (site.validationErrors && site.validationErrors[field]) {
            delete site.validationErrors[field];
        }
    });
    
    // SIMPLIFIED LOGIC: If returnTo=review-site-details, we're ALWAYS editing an existing site
    if (returnTo === 'review-site-details') {
        console.log(`üîÑ DIRECT RETURN: Redirecting back to review page after activity dates update with anchor`);
        return res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
    }
    
    // CONTINUE FLOW for new site creation
    // Check if we need to ask about descriptions
    const multiSiteChoice = req.session.data['manual-multiple-sites'];
    if (multiSiteChoice === 'No') {
        // Single site: always ask individual description
        res.redirect('/' + version + section + 'manual-entry/individual-site-activity-description?site=' + site.globalNumber);
    } else {
        // Multiple site: check if description question was answered
        if (!currentBatch.settings.sameActivityDescription) {
            // First site: ask about shared descriptions
            res.redirect('/' + version + section + 'manual-entry/same-activity-description?site=' + site.globalNumber);
        } else if (currentBatch.settings.sameActivityDescription === 'Yes') {
            // Shared descriptions: skip to coordinates
            res.redirect('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates?site=' + site.globalNumber);
        } else {
            // Individual descriptions: ask for this site
            res.redirect('/' + version + section + 'manual-entry/individual-site-activity-description?site=' + site.globalNumber);
        }
    }
});

// CONVERTED: Batch system shared activity dates GET route
router.get('/' + version + section + 'manual-entry/activity-dates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found for shared activity dates');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    // For shared dates, we use the batch settings data, not individual site data
    const sharedStartDate = currentBatch.settings?.sharedStartDate || { day: '', month: '', year: '' };
    const sharedEndDate = currentBatch.settings?.sharedEndDate || { day: '', month: '', year: '' };
    
    res.render(path.join(version, section, 'manual-entry', 'activity-dates'), {
        data: req.session.data,
        currentBatch: currentBatch,
        sharedStartDate: sharedStartDate,
        sharedEndDate: sharedEndDate,
        siteParam: siteParam,
        returnTo: returnTo,
        isEditing: returnTo === 'review-site-details',
        errors: {}
    });
});

// CONVERTED: Batch system shared activity dates POST route
router.post('/' + version + section + 'manual-entry/activity-dates-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    const startDay = req.body['start-date-date-input-day'];
    const startMonth = req.body['start-date-date-input-month'];
    const startYear = req.body['start-date-date-input-year'];
    
    const endDay = req.body['end-date-date-input-day'];
    const endMonth = req.body['end-date-date-input-month'];
    const endYear = req.body['end-date-date-input-year'];
    
    console.log(`Processing shared activity dates - Start: ${startDay}/${startMonth}/${startYear}, End: ${endDay}/${endMonth}/${endYear}`);
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found for shared activity dates');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    // Basic validation
    let isValid = true;
    let errors = {};
    
    if (!startDay || !startMonth || !startYear) {
        isValid = false;
        errors.startDate = 'Enter a complete start date';
    }
    
    if (!endDay || !endMonth || !endYear) {
        isValid = false;
        errors.endDate = 'Enter a complete end date';
    }
    
    if (!isValid) {
        return res.render(path.join(version, section, 'manual-entry', 'activity-dates'), {
            data: req.session.data,
            currentBatch: currentBatch,
            sharedStartDate: { day: startDay || '', month: startMonth || '', year: startYear || '' },
            sharedEndDate: { day: endDay || '', month: endMonth || '', year: endYear || '' },
            siteParam: siteParam,
            returnTo: returnTo,
            isEditing: returnTo === 'review-site-details',
            errors: errors
        });
    }
    
    // Store shared dates in batch settings
    if (!currentBatch.settings) {
        currentBatch.settings = {};
    }
    
    currentBatch.settings.sharedStartDate = {
        day: startDay || '',
        month: startMonth || '',
        year: startYear || ''
    };
    currentBatch.settings.sharedEndDate = {
        day: endDay || '',
        month: endMonth || '',
        year: endYear || ''
    };
    
    // Apply shared dates to ALL existing sites in the batch
    currentBatch.sites.forEach(site => {
        site.startDate = { ...currentBatch.settings.sharedStartDate };
        site.endDate = { ...currentBatch.settings.sharedEndDate };
    });
    
    console.log('Stored shared activity dates for all sites in batch');
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'manual-entry/review-site-details');
    } else {
        res.redirect('/' + version + section + 'manual-entry/same-activity-description?site=' + siteParam);
    }
});

// ===== MIGRATED: same-activity-description routes to unified model =====

// Are the activity descriptions the same for every site? - GET route
router.get('/' + version + section + 'manual-entry/same-activity-description', function (req, res) {
    
    const returnTo = req.query.returnTo;
    
    // Get or create current batch for flow control data
    let currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        currentBatch = initializeBatch(req.session, 'manual-entry');
    }
    
    res.render(version + section + 'manual-entry/same-activity-description', {
        data: req.session.data,
        currentBatch: currentBatch,
        returnTo: returnTo,
        errors: {}
    });
});

// Are the activity descriptions the same for every site? - POST route
router.post('/' + version + section + 'manual-entry/same-activity-description-router', function (req, res) {
    const selection = req.body['manual-same-activity-description'];
    const returnTo = req.query.returnTo;

    if (!selection) {
        const currentBatch = getCurrentBatch(req.session);
        return res.render(version + section + 'manual-entry/same-activity-description', {
            data: req.session.data,
            currentBatch: currentBatch,
            returnTo: returnTo,
            errors: { 'sameActivityDescription': 'Please select an option' }
        });
    }

    // Get current batch and store previous selection before updating
    const currentBatch = getCurrentBatch(req.session);
    const previousSelection = currentBatch && currentBatch.settings ? currentBatch.settings.sameActivityDescription : null;
    
    // Store the new selection in batch settings
    if (currentBatch) {
        if (!currentBatch.settings) {
            currentBatch.settings = {};
        }
        currentBatch.settings.sameActivityDescription = selection;
    }

    // If returning from review, handle shared description updates
    if (returnTo === 'review-site-details') {
        // If changing from Yes to No, copy shared description to individual sites
        if (selection === "No" && previousSelection === "Yes") {
            // Copy shared description to all batch sites
            const sharedDescription = currentBatch.settings.sharedDescription;
            
            if (sharedDescription && currentBatch.sites) {
                currentBatch.sites.forEach(site => {
                    site.description = sharedDescription;
                });
            }
            
            // Clear shared description from batch settings after copying
            currentBatch.settings.sharedDescription = '';
        }
        // If changing from No to Yes, use first site's description as shared description
        else if (selection === "Yes" && previousSelection === "No") {
            // Use first site's description as shared description
            if (currentBatch.sites && currentBatch.sites.length > 0) {
                const firstSite = currentBatch.sites[0];
                if (firstSite.description) {
                    currentBatch.settings.sharedDescription = firstSite.description;
                    
                    // Apply shared description to all sites
                    currentBatch.sites.forEach(site => {
                        site.description = currentBatch.settings.sharedDescription;
                    });
                }
            }
        }
        
        return res.redirect('/' + version + section + 'manual-entry/review-site-details');
    }

    // Route based on selection - use first site from batch
    const siteNumber = currentBatch.sites.length > 0 ? currentBatch.sites[0].globalNumber : 1;
    
    switch(selection) {
        case "Yes":
            res.redirect('activity-description?site=' + siteNumber);
            break;
        case "No":
            res.redirect('individual-site-activity-description?site=' + siteNumber);
            break;
        default:
            res.redirect('same-activity-description?site=' + siteNumber);
    }
});

// CONVERTED: Batch system individual site activity description GET route
router.get('/' + version + section + 'manual-entry/individual-site-activity-description', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for individual activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for individual activity description');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - individual-site-activity-description GET - editing from review');
    }
    
    res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-description'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: site.validationErrors || {},
        currentSiteFromRoute: site.globalNumber
    });
});

// SIMPLIFIED: Individual site activity description POST route
router.post('/' + version + section + 'manual-entry/individual-site-activity-description-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    const description = req.body['activity-details-text-area'];
    
    console.log(`=== ACTIVITY DESCRIPTION DEBUG ===`);
    console.log(`Site: ${siteParam}, returnTo: ${returnTo}, description: "${description}"`);
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Basic validation
    if (!description || description.trim() === '') {
        site.validationErrors = { description: 'Enter an activity description' };
        return res.render(path.join(version, section, 'manual-entry', 'individual-site-activity-description'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            returnTo: returnTo,
            errors: site.validationErrors
        });
    }
    
    // Update site in batch
    site.description = description.trim();
    if (site.validationErrors) delete site.validationErrors.description;
    
    // SIMPLE LOGIC: Return to review if editing, otherwise continue flow
    if (returnTo === 'review-site-details') {
        console.log(`üîÑ DIRECT RETURN: Redirecting back to review page with anchor`);
        return res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
    } else {
        console.log(`‚û°Ô∏è CONTINUE FLOW: Going to coordinates`);
        return res.redirect('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates?site=' + site.globalNumber);
    }
});

// CONVERTED: Batch system shared activity description GET route
router.get('/' + version + section + 'manual-entry/activity-description', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found for shared activity description');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    // For shared description, we use the batch settings data, not individual site data
    const sharedDescription = currentBatch.settings?.sharedDescription || '';
    
    res.render(path.join(version, section, 'manual-entry', 'activity-description'), {
        data: req.session.data,
        currentBatch: currentBatch,
        sharedDescription: sharedDescription,
        siteParam: siteParam,
        returnTo: returnTo,
        isEditing: returnTo === 'review-site-details',
        errors: {}
    });
});

// CONVERTED: Batch system shared activity description POST route
router.post('/' + version + section + 'manual-entry/activity-description-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    const description = req.body['activity-details-text-area'];
    
    console.log(`Processing shared activity description: "${description}"`);
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found for shared activity description');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    // Basic validation
    let isValid = true;
    let errors = {};
    
    if (!description || description.trim() === '') {
        isValid = false;
        errors.description = 'Enter an activity description';
    }
    
    if (!isValid) {
        return res.render(path.join(version, section, 'manual-entry', 'activity-description'), {
            data: req.session.data,
            currentBatch: currentBatch,
            sharedDescription: description || '',
            siteParam: siteParam,
            returnTo: returnTo,
            isEditing: returnTo === 'review-site-details',
            errors: errors
        });
    }
    
    // Store shared description in batch settings
    if (!currentBatch.settings) {
        currentBatch.settings = {};
    }
    
    currentBatch.settings.sharedDescription = description || '';
    
    // Apply shared description to ALL existing sites in the batch
    currentBatch.sites.forEach(site => {
        site.description = description || '';
    });
    
    console.log('Stored shared activity description for all sites in batch');
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        res.redirect('/' + version + section + 'manual-entry/review-site-details');
    } else {
        res.redirect('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates?site=' + siteParam);
    }
});

// ===== MIGRATED: coordinate entry method routes to unified model =====

// CONVERTED: Batch system coordinate entry method GET route
router.get('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for coordinate entry method');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for coordinate entry method');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - how-do-you-want-to-enter-the-coordinates GET - editing from review');
    } else if (parseInt(siteParam) > 1) {
        // SUBSEQUENT SITE: Set creation-review state so cancel returns to review page
        console.log(`üîÑ SUBSEQUENT SITE: Coordinates for site ${siteParam} - setting creation-review state`);
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - how-do-you-want-to-enter-the-coordinates GET - subsequent site creation');
    }
    
    res.render(version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates', {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: site.validationErrors || {}
    });
});

// CONVERTED: Batch system coordinate entry method POST route
router.post('/' + version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    const selection = req.body['manual-coordinate-entry-method'];
    
    console.log(`Processing coordinate entry method for site: ${siteParam}, selection: ${selection}`);
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for coordinate entry method update');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    if (!selection) {
        site.validationErrors = { ...site.validationErrors, coordinateEntryMethod: 'Please select how you want to enter coordinates' };
        return res.render(version + section + 'manual-entry/how-do-you-want-to-enter-the-coordinates', {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }

    // JOURNEY RESTART: Clear subsequent coordinate data when changing method from review page
    if (returnTo === 'review-site-details') {
        // Store the previous method to check if it's actually changing
        const previousMethod = site.coordinates && site.coordinates.entryMethod;
        
        if (previousMethod && previousMethod !== selection) {
            console.log(`üîÑ JOURNEY RESTART: Coordinate entry method changed from "${previousMethod}" to "${selection}" - clearing subsequent data`);
            
            // Clear ALL coordinate data except the method selection
            site.coordinates = {
                entryMethod: selection
            };
            
            // Set coordinate type based on selection (needed for journey routing)
            if (selection === "Enter one set of coordinates and a width to create a circular site") {
                site.coordinates.type = 'circle';
            } else if (selection === "Enter multiple sets of coordinates to mark the boundary of the site") {
                site.coordinates.type = 'polygon';
            }
            
            // Clear coordinate system selection (force user to choose again)
            delete site.coordinateSystem;
            
            // CRITICAL: Clear session data so coordinate system radio doesn't remain selected
            const currentSite = parseInt(siteParam);
            const siteDataKey = 'manual-coordinate-system-radios' + (currentSite === 1 ? '' : '-site-' + currentSite);
            delete req.session.data[siteDataKey];
            delete req.session.data['manual-coordinate-system-radios'];
            
            console.log(`üßπ Cleared ALL coordinate data AND session data for site ${site.globalNumber} due to method change`);
            console.log(`üîÑ JOURNEY RESTART: User will be taken through coordinate system ‚Üí coordinates ‚Üí width (if circular) ‚Üí review`);
        } else {
            // Same method selected, just update without clearing
            site.coordinates.entryMethod = selection;
            // Still need to set type for routing
            if (selection === "Enter one set of coordinates and a width to create a circular site") {
                site.coordinates.type = 'circle';
            } else if (selection === "Enter multiple sets of coordinates to mark the boundary of the site") {
                site.coordinates.type = 'polygon';
            }
        }
    } else {
        // Normal flow (not from review page)
        if (!site.coordinates) site.coordinates = {};
        site.coordinates.entryMethod = selection;
        // Set coordinate type based on selection
        if (selection === "Enter one set of coordinates and a width to create a circular site") {
            site.coordinates.type = 'circle';
        } else if (selection === "Enter multiple sets of coordinates to mark the boundary of the site") {
            site.coordinates.type = 'polygon';
        }
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        // JOURNEY RESTART: Continue through the journey instead of going directly back to review
        // This allows the user to complete the restarted coordinate entry journey
        console.log(`üîÑ JOURNEY RESTART: Continuing to coordinate system selection`);
        res.redirect('/' + version + section + 'manual-entry/which-coordinate-system?site=' + site.globalNumber + '&returnTo=review-site-details');
    } else {
        res.redirect('/' + version + section + 'manual-entry/which-coordinate-system?site=' + site.globalNumber);
    }
});

// ===== MIGRATED: coordinate system routes to unified model =====

// CONVERTED: Batch system coordinate system GET route
router.get('/' + version + section + 'manual-entry/which-coordinate-system', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for coordinate system');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for coordinate system');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - which-coordinate-system GET - editing from review');
    } else if (parseInt(siteParam) > 1) {
        // SUBSEQUENT SITE: Set creation-review state so cancel returns to review page
        console.log(`üîÑ SUBSEQUENT SITE: Coordinate system for site ${siteParam} - setting creation-review state`);
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - which-coordinate-system GET - subsequent site creation');
    }
    
    res.render(version + section + 'manual-entry/which-coordinate-system', {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: site.validationErrors || {}
    });
});

// CONVERTED: Batch system coordinate system POST route
router.post('/' + version + section + 'manual-entry/which-coordinate-system-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    const selection = req.body['manual-coordinate-system-radios'];
    
    console.log(`Processing coordinate system for site: ${siteParam}, selection: ${selection}`);
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for coordinate system update');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    if (!selection) {
        site.validationErrors = { ...site.validationErrors, coordinateSystem: 'Please select a coordinate system' };
        return res.render(version + section + 'manual-entry/which-coordinate-system', {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            errors: site.validationErrors
        });
    }

    // JOURNEY RESTART: Clear subsequent coordinate data when changing coordinate system from review page
    if (returnTo === 'review-site-details') {
        // Store the previous system to check if it's actually changing
        const previousSystem = site.coordinateSystem || (site.coordinates && site.coordinates.system);
        
        if (previousSystem && previousSystem !== selection) {
            console.log(`üîÑ JOURNEY RESTART: Coordinate system changed from "${previousSystem}" to "${selection}" - clearing subsequent data`);
            
            // Clear ALL coordinate values but keep type and entry method
            if (site.coordinates) {
                const preservedData = {
                    entryMethod: site.coordinates.entryMethod,
                    type: site.coordinates.type,
                    system: selection
                };
                
                // Clear all coordinate values (latitude, longitude, width, points, etc.)
                site.coordinates = preservedData;
            }
            
            // Update coordinate system
            site.coordinateSystem = selection;
            
            // CRITICAL: Clear session data so coordinate values don't remain in forms
            const currentSite = parseInt(siteParam);
            // Clear coordinate session data
            delete req.session.data['coordinates-latitude'];
            delete req.session.data['coordinates-longitude'];
            delete req.session.data['site-width'];
            // Clear site-specific coordinate data if it exists
            delete req.session.data[`manual-site-${currentSite}-coordinates-latitude`];
            delete req.session.data[`manual-site-${currentSite}-coordinates-longitude`];
            delete req.session.data[`manual-site-${currentSite}-site-width`];
            
            console.log(`üßπ Cleared ALL coordinate values AND session data for site ${site.globalNumber} due to system change`);
            console.log(`üîÑ JOURNEY RESTART: User will be taken through coordinates entry ‚Üí width (if circular) ‚Üí review`);
        } else {
            // Same system selected, just update without clearing
            if (!site.coordinates) site.coordinates = {};
            site.coordinates.system = selection;
            site.coordinateSystem = selection;
        }
    } else {
        // Normal flow (not from review page)
        if (!site.coordinates) site.coordinates = {};
        site.coordinates.system = selection;
        site.coordinateSystem = selection;
    }
    
    // Update coordinate format based on system
    if (selection === 'WGS84 (World Geodetic System 1984)') {
        site.coordinates.format = 'decimal-degrees';
    } else {
        site.coordinates.format = 'degrees-minutes-seconds';
    }
    
    // Clear coordinate system errors
    if (site.validationErrors && site.validationErrors.coordinateSystem) {
        delete site.validationErrors.coordinateSystem;
    }
    
    // Determine next step based on coordinate type
    if (returnTo === 'review-site-details') {
        // JOURNEY RESTART: Continue through the journey to complete all required steps
        // This is a coordinate system change from review page - user needs to complete the full journey
        console.log(`üîÑ JOURNEY RESTART: Continuing to coordinate entry after system change`);
        if (site.coordinates && site.coordinates.type === 'polygon') {
            res.redirect('/' + version + section + 'manual-entry/enter-multiple-coordinates?site=' + site.globalNumber + '&returnTo=review-site-details');
        } else {
            res.redirect('/' + version + section + 'manual-entry/enter-coordinates?site=' + site.globalNumber + '&returnTo=review-site-details');
        }
    } else {
        // Normal flow - continue through journey
        if (site.coordinates && site.coordinates.type === 'polygon') {
            res.redirect('/' + version + section + 'manual-entry/enter-multiple-coordinates?site=' + site.globalNumber);
        } else {
            res.redirect('/' + version + section + 'manual-entry/enter-coordinates?site=' + site.globalNumber);
        }
    }
});

// CONVERTED: Batch system coordinates GET route
router.get('/' + version + section + 'manual-entry/enter-coordinates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for coordinates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for coordinates entry');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - enter-coordinates GET - editing from review');
    } else if (parseInt(siteParam) > 1) {
        // SUBSEQUENT SITE: Set creation-review state so cancel returns to review page
        console.log(`üîÑ SUBSEQUENT SITE: Enter coordinates for site ${siteParam} - setting creation-review state`);
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - enter-coordinates GET - subsequent site creation');
    }
    
    res.render(path.join(version, section, 'manual-entry', 'enter-coordinates'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: site.validationErrors || {}
    });
});

// CONVERTED: Batch system enter multiple coordinates GET route
router.get('/' + version + section + 'manual-entry/enter-multiple-coordinates', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for multiple coordinates');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for multiple coordinates entry');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - enter-multiple-coordinates GET - editing from review');
    } else if (parseInt(siteParam) > 1) {
        // SUBSEQUENT SITE: Set creation-review state so cancel returns to review page
        console.log(`üîÑ SUBSEQUENT SITE: Multiple coordinates for site ${siteParam} - setting creation-review state`);
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - enter-multiple-coordinates GET - subsequent site creation');
    }
    
    // Enter multiple coordinates page - no validation errors on initial load

    res.render(version + section + 'manual-entry/enter-multiple-coordinates', {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: []
    });
});

// CONVERTED: Batch system coordinates POST route
router.post('/' + version + section + 'manual-entry/enter-coordinates-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    // FIXED: Get coordinates from form using correct field names from template
    const latitude = req.body['coordinates-latitude'];
    const longitude = req.body['coordinates-longitude'];
    const format = req.body['coordinate-format'] || 'decimal-degrees';
    
    console.log(`üìç Processing coordinates for site: ${siteParam}`);
    console.log(`üìç Form body received:`, req.body);
    console.log(`üìç Extracted - Lat: ${latitude}, Lon: ${longitude}, Format: ${format}`);
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-invoke-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for coordinates update');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Update coordinates directly in batch site
    if (!site.coordinates) site.coordinates = {};
    site.coordinates.latitude = latitude || '';
    site.coordinates.longitude = longitude || '';
    site.coordinates.format = format;
    
    // Also store in format expected by template (for circular sites)
    if (!site.coordinates.center) site.coordinates.center = {};
    site.coordinates.center.latitude = latitude || '';
    site.coordinates.center.longitude = longitude || '';
    
    // Basic validation
    let isValid = true;
    if (!latitude || !longitude) {
        isValid = false;
        site.validationErrors = { ...site.validationErrors, coordinates: 'Enter both latitude and longitude' };
    } else {
        // Clear coordinate errors if validation passes
        if (site.validationErrors) {
            delete site.validationErrors.coordinates;
        }
    }
    
    if (!isValid) {
        console.log('Coordinates validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'enter-coordinates'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            returnTo: returnTo,
            errors: site.validationErrors
        });
    }
    
    // Clear coordinate-related errors
    ['latitude', 'longitude'].forEach(field => {
        if (site.validationErrors && site.validationErrors[field]) {
            delete site.validationErrors[field];
        }
    });
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        // Check if this is part of a journey restart or an independent coordinate change
        // If the site doesn't have a width yet and it's a circular site, continue the journey
        // If it already has a width, this is likely an independent coordinate change
        if (site.coordinates.type === 'circle' && !site.coordinates.width) {
            // JOURNEY RESTART: Circular site without width - continue to width page
            console.log(`üîÑ JOURNEY RESTART: Continuing to width page for circular site (no width set)`);
            res.redirect('/' + version + section + 'manual-entry/site-width?site=' + site.globalNumber + '&returnTo=review-site-details');
        } else if (site.coordinates.type === 'polygon') {
            // JOURNEY RESTART: Polygon site - coordinates are complete, return to review
            console.log(`üîÑ JOURNEY RESTART: Polygon coordinates complete, returning to review with anchor`);
            res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
        } else {
            // INDEPENDENT CHANGE: Site already has width or is being edited independently
            console.log(`üîÑ INDEPENDENT CHANGE: Coordinates updated, returning directly to review with anchor`);
            res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
        }
    } else {
        // Normal flow - continue through journey (includes width page for circular sites)
        if (site.coordinates.type === 'circle') {
            // Circular site - need to get width
            res.redirect('/' + version + section + 'manual-entry/site-width?site=' + site.globalNumber);
        } else if (site.coordinates.type === 'polygon') {
            // Polygon site - need multiple coordinates (not implemented in this route)
            res.redirect('/' + version + section + 'manual-entry/enter-multiple-coordinates?site=' + site.globalNumber);
        } else {
            // Fallback - assume circular if not set
            res.redirect('/' + version + section + 'manual-entry/site-width?site=' + site.globalNumber);
        }
    }
    
    // Set mapImage for circular sites (will be finalized when width is set)
    if (isValid && site.coordinates.type === 'circle') {
        site.mapImage = '/public/images/worthing-map-circle-copy.jpg';
    }
});

// CONVERTED: Batch system site width GET route
router.get('/' + version + section + 'manual-entry/site-width', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    if (!siteParam) {
        console.log('No site parameter provided for site width');
        return res.redirect('/' + version + section + 'manual-entry/site-name');
    }
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for site width');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Track that user is editing from review page if accessed via change link
    if (returnTo === 'review-site-details') {
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - site-width GET - editing from review');
    } else if (parseInt(siteParam) > 1) {
        // SUBSEQUENT SITE: Set creation-review state so cancel returns to review page
        console.log(`üîÑ SUBSEQUENT SITE: Site width for site ${siteParam} - setting creation-review state`);
        updateReviewState(req.session, 'editing');
        logCancelState(req.session, 'manual entry - site-width GET - subsequent site creation');
    }
    
    res.render(path.join(version, section, 'manual-entry', 'site-width'), {
        data: req.session.data,
        site: site,
        isEditing: returnTo === 'review-site-details',
        returnTo: returnTo,
        errors: site.validationErrors || {}
    });
});

// CONVERTED: Batch system site width POST route
router.post('/' + version + section + 'manual-entry/site-width-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    
    // FIX: Add comprehensive form field debugging
    console.log('=== SITE WIDTH FORM DEBUG ===');
    console.log('Route:', req.originalUrl);
    console.log('Form body received:', Object.keys(req.body));
    console.log('Full form data:', req.body);
    console.log('=== END FORM DEBUG ===');
    
    const width = req.body['site-width'];
    
    console.log(`Processing site width for site: ${siteParam}`);
    console.log(`Extracted width: "${width}"`);
    
    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }
    
    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for site width update');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }
    
    // Update site width directly in batch site
    if (!site.coordinates) site.coordinates = {};
    site.coordinates.width = width || '';
    
    // Simple validation: field is required
    let isValid = true;
    if (!width || width.trim() === '') {
        isValid = false;
        site.validationErrors = { ...site.validationErrors, siteWidth: 'Enter the width of the circular site in metres' };
    } else {
        // Clear width errors if field has content
        if (site.validationErrors && site.validationErrors.siteWidth) {
            delete site.validationErrors.siteWidth;
        }
    }
    
    if (!isValid) {
        console.log('Site width validation failed:', site.validationErrors);
        return res.render(path.join(version, section, 'manual-entry', 'site-width'), {
            data: req.session.data,
            site: site,
            isEditing: returnTo === 'review-site-details',
            returnTo: returnTo,
            errors: site.validationErrors
        });
    }
    
    // Set mapImage for circular sites
    if (isValid && site.coordinates.type === 'circle') {
        site.mapImage = '/public/images/worthing-map-circle-copy.jpg';
    }
    
    // Determine next step
    if (returnTo === 'review-site-details') {
        // Returning from change link - use anchor to jump to specific site
        res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
    } else {
        // Completing site creation - load review page normally at top
        res.redirect('/' + version + section + 'manual-entry/review-site-details');
    }
});

// Review site details - GET route
router.get('/' + version + section + 'manual-entry/review-site-details', function (req, res) {
    console.log('=== REVIEW SITE DETAILS DEBUG ===');
    req.session.data['errorthispage'] = "false";
    req.session.data['errors'] = [];
    
    // Handle origin and state tracking
    if (req.query.camefromcheckanswers === 'true') {
        // User came from Check answers
        setOriginContext(req.session, 'check-answers');
        req.session.data['camefromcheckanswers'] = 'true';
        // If there's also a batchId, this is a saved batch from check answers
        if (req.query.batchId) {
            req.session.data['currentBatchId'] = req.query.batchId;
            updateReviewState(req.session, 'saved');
            logCancelState(req.session, 'manual entry - review-site-details GET - saved batch from check answers');
        } else {
            updateReviewState(req.session, 'visited');
            logCancelState(req.session, 'manual entry - review-site-details GET - active journey from check answers');
        }
    } else if (req.query.batchId) {
        req.session.data['currentBatchId'] = req.query.batchId;
        console.log('Set currentBatchId from query:', req.query.batchId);
        
        // Set origin context for saved batch review
        setOriginContext(req.session, 'task-list');
        
        // Mark that user is reviewing a previously saved batch
        updateReviewState(req.session, 'saved');
        logCancelState(req.session, 'manual entry - review-site-details GET - saved batch from your sites');
    } else {
        // Track review page visit for active journey
        updateReviewState(req.session, 'visited');
        logCancelState(req.session, 'manual entry - review-site-details GET - active journey');
    }
    
    console.log('Current session activity settings:', {
        'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
        'manual-same-activity-description': req.session.data['manual-same-activity-description'],
        'manual-start-date-date-input-day': req.session.data['manual-start-date-date-input-day'],
        'manual-activity-details-text-area': req.session.data['manual-activity-details-text-area']
    });
    
    // REMOVED: Complex conversion function no longer needed - batch system already works correctly
    
    // Get current batch
    const currentBatch = getCurrentBatch(req.session);
    console.log('Current batch after conversion:', currentBatch ? {
        id: currentBatch.id,
        sitesCount: currentBatch.sites.length,
        settings: currentBatch.settings
    } : 'null');
    
    // Determine if we're in active editing mode or reviewing a saved batch
    const isActiveEditing = !req.query.batchId || req.session.data['siteDetailsSaved'] !== true;
    console.log('Is active editing:', isActiveEditing);
    
    // If we're reviewing a saved batch, populate session data from batch settings
    if (currentBatch && currentBatch.settings && req.query.batchId) {
        console.log('Populating session data from batch settings...');
        // Populate activity settings from batch
        req.session.data['manual-same-activity-dates'] = currentBatch.settings.sameActivityDates;
        req.session.data['manual-same-activity-description'] = currentBatch.settings.sameActivityDescription;
        
        // Populate shared dates from batch
        if (currentBatch.settings.sharedStartDate) {
            req.session.data['manual-start-date-date-input-day'] = currentBatch.settings.sharedStartDate.day;
            req.session.data['manual-start-date-date-input-month'] = currentBatch.settings.sharedStartDate.month;
            req.session.data['manual-start-date-date-input-year'] = currentBatch.settings.sharedStartDate.year;
        }
        
        if (currentBatch.settings.sharedEndDate) {
            req.session.data['manual-end-date-date-input-day'] = currentBatch.settings.sharedEndDate.day;
            req.session.data['manual-end-date-date-input-month'] = currentBatch.settings.sharedEndDate.month;
            req.session.data['manual-end-date-date-input-year'] = currentBatch.settings.sharedEndDate.year;
        }
        
        // Populate shared description from batch
        if (currentBatch.settings.sharedDescription) {
            req.session.data['manual-activity-details-text-area'] = currentBatch.settings.sharedDescription;
        }
        
        console.log('Session data after populating from batch:', {
            'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
            'manual-same-activity-description': req.session.data['manual-same-activity-description']
        });
        
        // NOTE: We don't populate session data from batch sites here because:
        // 1. The template reads from the sites array (batch data), not session data
        // 2. Session data should only be populated when editing forms
        // 3. Populating here overwrites fresh session data with old batch data
        
        // Update current site number to match the batch
        if (currentBatch.sites && currentBatch.sites.length > 0) {
            req.session.data['manual-current-site'] = currentBatch.sites.length;
        }
    }
    
    // Only pass the current batch's sites to the template
    let sites = [];
    if (typeof getCurrentBatch === 'function') {
        const batch = getCurrentBatch(req.session);
        if (batch) {
            sites = batch.sites;
        }
    }
    
    console.log('Final sites to render:', sites.length);
    console.log('Final session activity settings for template:', {
        'manual-same-activity-dates': req.session.data['manual-same-activity-dates'],
        'manual-same-activity-description': req.session.data['manual-same-activity-description']
    });
    
    // Get the current batch to pass to template
    const batchForTemplate = getCurrentBatch(req.session);
    
    console.log('=== END REVIEW SITE DETAILS DEBUG ===');
    
    res.render(version + section + 'manual-entry/review-site-details', { 
        sites,
        isActiveEditing,
        currentBatch: batchForTemplate
    });
});

// Review site details - POST route
router.post('/' + version + section + 'manual-entry/review-site-details-router', function (req, res) {
    // REMOVED: Complex conversion function no longer needed - batch system already works correctly
    
    // Get current batch before clearing
    const currentBatch = getCurrentBatch(req.session);
    
    // CRITICAL FIX: Populate batch settings with session data before saving
    if (currentBatch) {
        if (!currentBatch.settings) {
            currentBatch.settings = {};
        }
        
        // Store manual entry session data into batch settings for future completeness checks
        currentBatch.settings.sameActivityDates = req.session.data['manual-same-activity-dates'];
        currentBatch.settings.sameActivityDescription = req.session.data['manual-same-activity-description'];
        
        // Store shared dates if they exist
        if (req.session.data['manual-start-date-date-input-day']) {
            currentBatch.settings.sharedStartDate = {
                day: req.session.data['manual-start-date-date-input-day'],
                month: req.session.data['manual-start-date-date-input-month'],
                year: req.session.data['manual-start-date-date-input-year']
            };
        }
        
        if (req.session.data['manual-end-date-date-input-day']) {
            currentBatch.settings.sharedEndDate = {
                day: req.session.data['manual-end-date-date-input-day'],
                month: req.session.data['manual-end-date-date-input-month'],
                year: req.session.data['manual-end-date-date-input-year']
            };
        }
        
        // Store shared description if it exists
        if (req.session.data['manual-activity-details-text-area']) {
            currentBatch.settings.sharedDescription = req.session.data['manual-activity-details-text-area'];
        }
        
        // Mark batch as saved for future status determination
        currentBatch.saved = true;
        
        console.log('‚úÖ Manual entry batch settings populated:', {
            sameActivityDates: currentBatch.settings.sameActivityDates,
            sameActivityDescription: currentBatch.settings.sameActivityDescription,
            hasSharedDates: !!currentBatch.settings.sharedStartDate,
            hasSharedDescription: !!currentBatch.settings.sharedDescription
        });
    }
    
    // Use the existing current batch for completeness checks
    let hasSiteIncomplete = false;
    let sites = [];
    if (currentBatch) {
        sites = currentBatch.sites;
    }
    
    // Determine if this is a single site journey - same logic as template
    const isMultipleSitesJourney = req.session.data['manual-multiple-sites'] === 'Yes';
    
    if (sites.length > 0) {
        for (const site of sites) {
            // Only require site name for multiple site journeys
            if (isMultipleSitesJourney && !site.name) {
                hasSiteIncomplete = true;
            }
            
            // For single sites, always check dates and descriptions
            // For multiple sites, check based on user choices
            if (isMultipleSitesJourney) {
                if (req.session.data['manual-same-activity-dates'] === "No") {
                    if (!site.startDate || !site.startDate.day) {
                        hasSiteIncomplete = true;
                    }
                }
                if (req.session.data['manual-same-activity-description'] === "No") {
                    if (!site.description) {
                        hasSiteIncomplete = true;
                    }
                }
            } else {
                // Single site journey: always require dates and description
                if (!site.startDate || !site.startDate.day) {
                    hasSiteIncomplete = true;
                }
                if (!site.description) {
                    hasSiteIncomplete = true;
                }
            }
        }
        
        console.log(`üîç Completeness check - isMultipleSitesJourney: ${isMultipleSitesJourney}, hasSiteIncomplete: ${hasSiteIncomplete}`);
        
        if (hasSiteIncomplete) {
            req.session.data['exempt-information-3-status'] = 'in-progress';
        } else {
            req.session.data['exempt-information-3-status'] = 'completed';
        }
    } else {
        req.session.data['exempt-information-3-status'] = 'cannot-start';
    }
    
    // CRITICAL FIX: Rebuild global sites array from all batches after batch settings are populated
    if (req.session.data['siteBatches']) {
        req.session.data['sites'] = req.session.data['siteBatches'].flatMap(batch => batch.sites);
        console.log('üîÑ Rebuilt global sites array from all batches, total sites:', req.session.data['sites'].length);
    }
    
    // Mark the task as completed and clear the current batch ID so we can start fresh next time
    req.session.data['siteDetailsSaved'] = true;
    
    // Track that review page has been saved
    updateReviewState(req.session, 'saved');
    logCancelState(req.session, 'manual entry - review-site-details POST - sites saved');
    
    // Store batch info for task list navigation
    if (currentBatch) {
        req.session.data['lastBatchType'] = currentBatch.entryMethod;
        req.session.data['lastBatchId'] = currentBatch.id;
    }
    
    delete req.session.data['currentBatchId'];
    
    // Check if we came from check answers page
    if (req.session.data['camefromcheckanswers'] === 'true') {
        req.session.data['camefromcheckanswers'] = false;
        res.redirect('../check-answers-multiple-sites');
    } else {
        res.redirect('../task-list');
    }
});

// ===== MIGRATED: Add next site - GET route =====
router.get('/' + version + section + 'manual-entry/add-next-site-router', function (req, res) {
    // Get next global site number
    const nextGlobalSiteNumber = (req.session.data['globalSiteCounter'] || 0) + 1;
    
    // EDGE CASE FIX: If batchId is provided (e.g., from back button after saving),
    // reactivate that batch so the new site gets added to it
    if (req.query.batchId) {
        console.log(`üîÑ EDGE CASE: Reactivating batch ${req.query.batchId} for site ${nextGlobalSiteNumber}`);
        req.session.data['currentBatchId'] = req.query.batchId;
    }
    
    // Clear any stale session parameters
    delete req.session.data['returnTo'];
    delete req.session.data['fromReviewSiteDetails'];
    delete req.session.data['currentManualEntrySiteId'];
    
    // Clear session data that might contaminate the new site
    clearCurrentSiteSessionData(req.session);
    
    console.log(`Starting new site ${nextGlobalSiteNumber} - session cleared`);
    
    // Redirect to site name page for the new site
    res.redirect('site-name?site=' + nextGlobalSiteNumber);
});

// CONVERTED: Batch system multiple coordinates POST route
router.post('/' + version + section + 'manual-entry/enter-multiple-coordinates-router', function (req, res) {
    const siteParam = req.query.site;
    const returnTo = req.query.returnTo;
    


    // Get current batch and find site
    const currentBatch = getCurrentBatch(req.session);
    if (!currentBatch) {
        console.log('No current batch found');
        return res.redirect('/' + version + section + 'manual-entry/does-your-project-involve-more-than-one-site');
    }

    const site = currentBatch.sites.find(s => s.globalNumber === parseInt(siteParam));
    if (!site) {
        console.log('Site not found for multiple coordinates update');
        return res.redirect('/' + version + section + 'manual-entry/site-name?site=' + siteParam);
    }

    // Extract coordinate points from form data
    let coordinatePoints = [];
    let errors = [];
    let hasError = false;

    // Get coordinate system to determine labels
    const system = site.coordinateSystem || site.coordinates?.system;
    const usingOSGB36 = system === "OSGB36 (National Grid)";
    const latLabel = usingOSGB36 ? "Eastings" : "Latitude";
    const longLabel = usingOSGB36 ? "Northings" : "Longitude";

    // Check points 1-5
    for (let i = 1; i <= 5; i++) {
        const latValue = req.body[`coordinates-point-${i}-latitude`];
        const longValue = req.body[`coordinates-point-${i}-longitude`];
        
        const pointLabel = i === 1 ? "start and end point" : `point ${i}`;
        
        // Points 1-3 are required, 4-5 are optional
        const isRequired = i <= 3;
        const hasLatitude = latValue && latValue.trim() !== '';
        const hasLongitude = longValue && longValue.trim() !== '';
        
        if (isRequired) {
            // Required points must have both coordinates
            if (!hasLatitude) {
                hasError = true;
                errors.push({
                    text: `Enter the ${latLabel.toLowerCase()} of ${pointLabel}`,
                    href: `#coordinates-point-${i}-latitude`
                });
            }
            if (!hasLongitude) {
                hasError = true;
                errors.push({
                    text: `Enter the ${longLabel.toLowerCase()} of ${pointLabel}`,
                    href: `#coordinates-point-${i}-longitude`
                });
            }
        } else {
            // Optional points: if one coordinate is provided, both must be provided
            if ((hasLatitude && !hasLongitude) || (!hasLatitude && hasLongitude)) {
                hasError = true;
                errors.push({
                    text: `Enter both ${latLabel.toLowerCase()} and ${longLabel.toLowerCase()} for ${pointLabel}, or leave both empty`,
                    href: `#coordinates-point-${i}-latitude`
                });
            }
        }
        
        // If we have both coordinates, add to the points array
        if (hasLatitude && hasLongitude) {
            coordinatePoints.push({
                latitude: latValue.trim(),
                longitude: longValue.trim()
            });
        }
    }

    // If there are validation errors, re-render the form
    if (hasError) {
        console.log('Multiple coordinates validation failed:', errors);
        
        // Store form data back to site.coordinates.points for re-display (matching template structure)
        if (!site.coordinates) site.coordinates = {};
        site.coordinates.points = [];
        for (let i = 1; i <= 5; i++) {
            const lat = req.body[`coordinates-point-${i}-latitude`] || '';
            const long = req.body[`coordinates-point-${i}-longitude`] || '';
            site.coordinates.points[i-1] = {
                latitude: lat,
                longitude: long
            };
        }
        
        return res.render(version + section + 'manual-entry/enter-multiple-coordinates', {
            data: req.session.data,
            site: site,
            errors: errors,
            isEditing: returnTo === 'review-site-details'
        });
    }

    // Update coordinates directly in batch site
    if (!site.coordinates) site.coordinates = {};
    site.coordinates.type = 'polygon';
    site.coordinates.points = coordinatePoints;
    
    // Set mapImage based on number of points
    const numPoints = coordinatePoints.length;
    if (numPoints === 3) {
        site.mapImage = '/public/images/worthing-map-3-points-copy.jpg';
    } else if (numPoints === 4) {
        site.mapImage = '/public/images/worthing-map-4-points-copy.jpg';
    } else if (numPoints >= 5) {
        site.mapImage = '/public/images/worthing-map-5-points-copy.jpg';
    } else {
        // Fallback for unexpected number of points
        site.mapImage = '/public/images/worthing-map-drawn-copy.jpg';
    }

    // Determine next step
    if (returnTo === 'review-site-details') {
        // Returning from change link - use anchor to jump to specific site
        res.redirect('/' + version + section + 'manual-entry/review-site-details?site=' + site.globalNumber + '#site-' + site.globalNumber + '-details');
    } else {
        // Completing site creation - load review page normally at top
        res.redirect('/' + version + section + 'manual-entry/review-site-details');
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////
// Cancel actions for manual entry
// These redirect to the main cancel handlers in the parent exemption routes
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Manual entry cancel route handlers - redirect to main state-based handler
 * These maintain backward compatibility while using the new cancel system
 */
router.get('/' + version + section + 'manual-entry/cancel-site-details', function (req, res) {
    logCancelState(req.session, 'manual-entry/cancel-site-details - redirecting to main handler');
    res.redirect('../cancel-site-details');
});

router.get('/' + version + section + 'manual-entry/cancel-to-review', function (req, res) {
    logCancelState(req.session, 'manual-entry/cancel-to-review - redirecting to main handler');
    res.redirect('../cancel-site-details');
});

router.get('/' + version + section + 'manual-entry/cancel-from-review-site-details', function (req, res) {
    logCancelState(req.session, 'manual-entry/cancel-from-review-site-details - redirecting to main handler');
    res.redirect('../cancel-site-details');
});

}